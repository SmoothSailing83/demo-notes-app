"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.stageDependencies = exports.bundle = exports.BUNDLER_DEPENDENCIES_CACHE = exports.DEPENDENCY_EXCLUDES = void 0;
/**
 * This file is copied from https://github.com/aws/aws-cdk/blob/master/packages/@aws-cdk/aws-lambda-python/lib/bundling.ts
 */
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
const cdk = __importStar(require("@aws-cdk/core"));
const lambda = __importStar(require("@aws-cdk/aws-lambda"));
/**
 * Dependency files to exclude from the asset hash.
 */
exports.DEPENDENCY_EXCLUDES = ["*.pyc"];
/**
 * The location in the image that the bundler image caches dependencies.
 */
exports.BUNDLER_DEPENDENCIES_CACHE = "/var/dependencies";
/**
 * Produce bundled Lambda asset code
 */
function bundle(options) {
    const { entry, runtime, outputPathSuffix, installCommands } = options;
    const stagedir = cdk.FileSystem.mkdtemp("python-bundling-");
    const hasDeps = stageDependencies(entry, stagedir);
    const hasInstallCommands = stageInstallCommands(installCommands || [], stagedir);
    const depsCommand = chain([
        hasDeps || hasInstallCommands
            ? `rsync -r ${exports.BUNDLER_DEPENDENCIES_CACHE}/. ${cdk.AssetStaging.BUNDLING_OUTPUT_DIR}/${outputPathSuffix}`
            : "",
        `rsync -r . ${cdk.AssetStaging.BUNDLING_OUTPUT_DIR}/${outputPathSuffix}`,
    ]);
    // Determine which dockerfile to use. When dependencies are present, we use a
    // Dockerfile that can create a cacheable layer. We can't use this Dockerfile
    // if there aren't dependencies or the Dockerfile will complain about missing
    // sources.
    const dockerfile = hasInstallCommands
        ? "Dockerfile.custom"
        : hasDeps
            ? "Dockerfile.dependencies"
            : "Dockerfile";
    // copy Dockerfile to workdir
    fs.copyFileSync(path.join(__dirname, "../../../assets/python", dockerfile), path.join(stagedir, dockerfile));
    const image = cdk.BundlingDockerImage.fromAsset(stagedir, {
        buildArgs: {
            IMAGE: runtime.bundlingDockerImage.image,
        },
        file: dockerfile,
    });
    return lambda.Code.fromAsset(entry, {
        assetHashType: options.assetHashType,
        assetHash: options.assetHash,
        exclude: exports.DEPENDENCY_EXCLUDES,
        bundling: {
            image,
            command: ["bash", "-c", depsCommand],
        },
    });
}
exports.bundle = bundle;
/**
 * Checks to see if the `entry` directory contains a type of dependency that
 * we know how to install.
 */
function stageDependencies(entry, stagedir) {
    const prefixes = ["Pipfile", "pyproject", "poetry", "requirements.txt"];
    let found = false;
    for (const file of fs.readdirSync(entry)) {
        for (const prefix of prefixes) {
            if (file.startsWith(prefix)) {
                fs.copyFileSync(path.join(entry, file), path.join(stagedir, file));
                found = true;
            }
        }
    }
    return found;
}
exports.stageDependencies = stageDependencies;
function stageInstallCommands(installCommands, stagedir) {
    let found = false;
    if (installCommands.length > 0) {
        const filePath = path.join(stagedir, "sst-deps-install-command.sh");
        fs.writeFileSync(filePath, installCommands.join(" && "));
        fs.chmodSync(filePath, "755");
        found = true;
    }
    return found;
}
function chain(commands) {
    return commands.filter((c) => !!c).join(" && ");
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnVuZGxpbmcuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvdXRpbC9weXRob24vYnVuZGxpbmcudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztHQUVHO0FBQ0gsdUNBQXlCO0FBQ3pCLDJDQUE2QjtBQUM3QixtREFBcUM7QUFDckMsNERBQThDO0FBRTlDOztHQUVHO0FBQ1UsUUFBQSxtQkFBbUIsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0FBRTdDOztHQUVHO0FBQ1UsUUFBQSwwQkFBMEIsR0FBRyxtQkFBbUIsQ0FBQztBQWdFOUQ7O0dBRUc7QUFDSCxTQUFnQixNQUFNLENBQUMsT0FBd0I7SUFDN0MsTUFBTSxFQUFFLEtBQUssRUFBRSxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsZUFBZSxFQUFFLEdBQUcsT0FBTyxDQUFDO0lBRXRFLE1BQU0sUUFBUSxHQUFHLEdBQUcsQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLGtCQUFrQixDQUFDLENBQUM7SUFDNUQsTUFBTSxPQUFPLEdBQUcsaUJBQWlCLENBQUMsS0FBSyxFQUFFLFFBQVEsQ0FBQyxDQUFDO0lBQ25ELE1BQU0sa0JBQWtCLEdBQUcsb0JBQW9CLENBQzdDLGVBQWUsSUFBSSxFQUFFLEVBQ3JCLFFBQVEsQ0FDVCxDQUFDO0lBRUYsTUFBTSxXQUFXLEdBQUcsS0FBSyxDQUFDO1FBQ3hCLE9BQU8sSUFBSSxrQkFBa0I7WUFDM0IsQ0FBQyxDQUFDLFlBQVksa0NBQTBCLE1BQU0sR0FBRyxDQUFDLFlBQVksQ0FBQyxtQkFBbUIsSUFBSSxnQkFBZ0IsRUFBRTtZQUN4RyxDQUFDLENBQUMsRUFBRTtRQUNOLGNBQWMsR0FBRyxDQUFDLFlBQVksQ0FBQyxtQkFBbUIsSUFBSSxnQkFBZ0IsRUFBRTtLQUN6RSxDQUFDLENBQUM7SUFFSCw2RUFBNkU7SUFDN0UsNkVBQTZFO0lBQzdFLDZFQUE2RTtJQUM3RSxXQUFXO0lBQ1gsTUFBTSxVQUFVLEdBQUcsa0JBQWtCO1FBQ25DLENBQUMsQ0FBQyxtQkFBbUI7UUFDckIsQ0FBQyxDQUFDLE9BQU87WUFDVCxDQUFDLENBQUMseUJBQXlCO1lBQzNCLENBQUMsQ0FBQyxZQUFZLENBQUM7SUFFakIsNkJBQTZCO0lBQzdCLEVBQUUsQ0FBQyxZQUFZLENBQ2IsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsd0JBQXdCLEVBQUUsVUFBVSxDQUFDLEVBQzFELElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLFVBQVUsQ0FBQyxDQUNoQyxDQUFDO0lBRUYsTUFBTSxLQUFLLEdBQUcsR0FBRyxDQUFDLG1CQUFtQixDQUFDLFNBQVMsQ0FBQyxRQUFRLEVBQUU7UUFDeEQsU0FBUyxFQUFFO1lBQ1QsS0FBSyxFQUFFLE9BQU8sQ0FBQyxtQkFBbUIsQ0FBQyxLQUFLO1NBQ3pDO1FBQ0QsSUFBSSxFQUFFLFVBQVU7S0FDakIsQ0FBQyxDQUFDO0lBRUgsT0FBTyxNQUFNLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLEVBQUU7UUFDbEMsYUFBYSxFQUFFLE9BQU8sQ0FBQyxhQUFhO1FBQ3BDLFNBQVMsRUFBRSxPQUFPLENBQUMsU0FBUztRQUM1QixPQUFPLEVBQUUsMkJBQW1CO1FBQzVCLFFBQVEsRUFBRTtZQUNSLEtBQUs7WUFDTCxPQUFPLEVBQUUsQ0FBQyxNQUFNLEVBQUUsSUFBSSxFQUFFLFdBQVcsQ0FBQztTQUNyQztLQUNGLENBQUMsQ0FBQztBQUNMLENBQUM7QUFqREQsd0JBaURDO0FBRUQ7OztHQUdHO0FBQ0gsU0FBZ0IsaUJBQWlCLENBQUMsS0FBYSxFQUFFLFFBQWdCO0lBQy9ELE1BQU0sUUFBUSxHQUFHLENBQUMsU0FBUyxFQUFFLFdBQVcsRUFBRSxRQUFRLEVBQUUsa0JBQWtCLENBQUMsQ0FBQztJQUV4RSxJQUFJLEtBQUssR0FBRyxLQUFLLENBQUM7SUFDbEIsS0FBSyxNQUFNLElBQUksSUFBSSxFQUFFLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxFQUFFO1FBQ3hDLEtBQUssTUFBTSxNQUFNLElBQUksUUFBUSxFQUFFO1lBQzdCLElBQUksSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsRUFBRTtnQkFDM0IsRUFBRSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDO2dCQUNuRSxLQUFLLEdBQUcsSUFBSSxDQUFDO2FBQ2Q7U0FDRjtLQUNGO0lBRUQsT0FBTyxLQUFLLENBQUM7QUFDZixDQUFDO0FBZEQsOENBY0M7QUFFRCxTQUFTLG9CQUFvQixDQUMzQixlQUF5QixFQUN6QixRQUFnQjtJQUVoQixJQUFJLEtBQUssR0FBRyxLQUFLLENBQUM7SUFDbEIsSUFBSSxlQUFlLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtRQUM5QixNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSw2QkFBNkIsQ0FBQyxDQUFDO1FBQ3BFLEVBQUUsQ0FBQyxhQUFhLENBQUMsUUFBUSxFQUFFLGVBQWUsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztRQUN6RCxFQUFFLENBQUMsU0FBUyxDQUFDLFFBQVEsRUFBRSxLQUFLLENBQUMsQ0FBQztRQUM5QixLQUFLLEdBQUcsSUFBSSxDQUFDO0tBQ2Q7SUFFRCxPQUFPLEtBQUssQ0FBQztBQUNmLENBQUM7QUFFRCxTQUFTLEtBQUssQ0FBQyxRQUFrQjtJQUMvQixPQUFPLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7QUFDbEQsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVGhpcyBmaWxlIGlzIGNvcGllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9hd3MvYXdzLWNkay9ibG9iL21hc3Rlci9wYWNrYWdlcy9AYXdzLWNkay9hd3MtbGFtYmRhLXB5dGhvbi9saWIvYnVuZGxpbmcudHNcbiAqL1xuaW1wb3J0ICogYXMgZnMgZnJvbSBcImZzXCI7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gXCJwYXRoXCI7XG5pbXBvcnQgKiBhcyBjZGsgZnJvbSBcIkBhd3MtY2RrL2NvcmVcIjtcbmltcG9ydCAqIGFzIGxhbWJkYSBmcm9tIFwiQGF3cy1jZGsvYXdzLWxhbWJkYVwiO1xuXG4vKipcbiAqIERlcGVuZGVuY3kgZmlsZXMgdG8gZXhjbHVkZSBmcm9tIHRoZSBhc3NldCBoYXNoLlxuICovXG5leHBvcnQgY29uc3QgREVQRU5ERU5DWV9FWENMVURFUyA9IFtcIioucHljXCJdO1xuXG4vKipcbiAqIFRoZSBsb2NhdGlvbiBpbiB0aGUgaW1hZ2UgdGhhdCB0aGUgYnVuZGxlciBpbWFnZSBjYWNoZXMgZGVwZW5kZW5jaWVzLlxuICovXG5leHBvcnQgY29uc3QgQlVORExFUl9ERVBFTkRFTkNJRVNfQ0FDSEUgPSBcIi92YXIvZGVwZW5kZW5jaWVzXCI7XG5cbi8qKlxuICogT3B0aW9ucyBmb3IgYnVuZGxpbmdcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBCdW5kbGluZ09wdGlvbnMge1xuICAvKipcbiAgICogRW50cnkgcGF0aFxuICAgKi9cbiAgcmVhZG9ubHkgZW50cnk6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIHJ1bnRpbWUgb2YgdGhlIGxhbWJkYSBmdW5jdGlvblxuICAgKi9cbiAgcmVhZG9ubHkgcnVudGltZTogbGFtYmRhLlJ1bnRpbWU7XG5cbiAgLyoqXG4gICAqIE91dHB1dCBwYXRoIHN1ZmZpeCAoJ3B5dGhvbicgZm9yIGEgbGF5ZXIsICcuJyBvdGhlcndpc2UpXG4gICAqL1xuICByZWFkb25seSBvdXRwdXRQYXRoU3VmZml4OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgaG93IGFzc2V0IGhhc2ggaXMgY2FsY3VsYXRlZC4gQXNzZXRzIHdpbGwgZ2V0IHJlYnVpbGQgYW5kXG4gICAqIHVwbG9hZGVkIG9ubHkgaWYgdGhlaXIgaGFzaCBoYXMgY2hhbmdlZC5cbiAgICpcbiAgICogSWYgYXNzZXQgaGFzaCBpcyBzZXQgdG8gYFNPVVJDRWAgKGRlZmF1bHQpLCB0aGVuIG9ubHkgY2hhbmdlcyB0byB0aGUgc291cmNlXG4gICAqIGRpcmVjdG9yeSB3aWxsIGNhdXNlIHRoZSBhc3NldCB0byByZWJ1aWxkLiBUaGlzIG1lYW5zLCBmb3IgZXhhbXBsZSwgdGhhdCBpblxuICAgKiBvcmRlciB0byBwaWNrIHVwIGEgbmV3IGRlcGVuZGVuY3kgdmVyc2lvbiwgYSBjaGFuZ2UgbXVzdCBiZSBtYWRlIHRvIHRoZVxuICAgKiBzb3VyY2UgdHJlZS4gSWRlYWxseSwgdGhpcyBjYW4gYmUgaW1wbGVtZW50ZWQgYnkgaW5jbHVkaW5nIGEgZGVwZW5kZW5jeVxuICAgKiBsb2NrZmlsZSBpbiB5b3VyIHNvdXJjZSB0cmVlIG9yIHVzaW5nIGZpeGVkIGRlcGVuZGVuY2llcy5cbiAgICpcbiAgICogSWYgdGhlIGFzc2V0IGhhc2ggaXMgc2V0IHRvIGBPVVRQVVRgLCB0aGUgaGFzaCBpcyBjYWxjdWxhdGVkIGFmdGVyXG4gICAqIGJ1bmRsaW5nLiBUaGlzIG1lYW5zIHRoYXQgYW55IGNoYW5nZSBpbiB0aGUgb3V0cHV0IHdpbGwgY2F1c2UgdGhlIGFzc2V0IHRvXG4gICAqIGJlIGludmFsaWRhdGVkIGFuZCB1cGxvYWRlZC4gQmVhciBpbiBtaW5kIHRoYXQgYHBpcGAgYWRkcyB0aW1lc3RhbXBzIHRvXG4gICAqIGRlcGVuZGVuY2llcyBpdCBpbnN0YWxscywgd2hpY2ggaW1wbGllcyB0aGF0IGluIHRoaXMgbW9kZSBQeXRob24gYnVuZGxlc1xuICAgKiB3aWxsIF9hbHdheXNfIGdldCByZWJ1aWxkIGFuZCB1cGxvYWRlZC4gTm9ybWFsbHkgdGhpcyBpcyBhbiBhbnRpLXBhdHRlcm5cbiAgICogc2luY2UgYnVpbGRcbiAgICpcbiAgICogQGRlZmF1bHQgQXNzZXRIYXNoVHlwZS5TT1VSQ0UgQnkgZGVmYXVsdCwgaGFzaCBpcyBjYWxjdWxhdGVkIGJhc2VkIG9uIHRoZVxuICAgKiBjb250ZW50cyBvZiB0aGUgc291cmNlIGRpcmVjdG9yeS4gSWYgYGFzc2V0SGFzaGAgaXMgYWxzbyBzcGVjaWZpZWQsIHRoZVxuICAgKiBkZWZhdWx0IGlzIGBDVVNUT01gLiBUaGlzIG1lYW5zIHRoYXQgb25seSB1cGRhdGVzIHRvIHRoZSBzb3VyY2Ugd2lsbCBjYXVzZVxuICAgKiB0aGUgYXNzZXQgdG8gcmVidWlsZC5cbiAgICovXG4gIHJlYWRvbmx5IGFzc2V0SGFzaFR5cGU/OiBjZGsuQXNzZXRIYXNoVHlwZTtcblxuICAvKipcbiAgICogU3BlY2lmeSBhIGN1c3RvbSBoYXNoIGZvciB0aGlzIGFzc2V0LiBJZiBgYXNzZXRIYXNoVHlwZWAgaXMgc2V0IGl0IG11c3RcbiAgICogYmUgc2V0IHRvIGBBc3NldEhhc2hUeXBlLkNVU1RPTWAuIEZvciBjb25zaXN0ZW5jeSwgdGhpcyBjdXN0b20gaGFzaCB3aWxsXG4gICAqIGJlIFNIQTI1NiBoYXNoZWQgYW5kIGVuY29kZWQgYXMgaGV4LiBUaGUgcmVzdWx0aW5nIGhhc2ggd2lsbCBiZSB0aGUgYXNzZXRcbiAgICogaGFzaC5cbiAgICpcbiAgICogTk9URTogdGhlIGhhc2ggaXMgdXNlZCBpbiBvcmRlciB0byBpZGVudGlmeSBhIHNwZWNpZmljIHJldmlzaW9uIG9mIHRoZSBhc3NldCwgYW5kXG4gICAqIHVzZWQgZm9yIG9wdGltaXppbmcgYW5kIGNhY2hpbmcgZGVwbG95bWVudCBhY3Rpdml0aWVzIHJlbGF0ZWQgdG8gdGhpcyBhc3NldCBzdWNoIGFzXG4gICAqIHBhY2thZ2luZywgdXBsb2FkaW5nIHRvIEFtYXpvbiBTMywgZXRjLiBJZiB5b3UgY2hvc2UgdG8gY3VzdG9taXplIHRoZSBoYXNoLCB5b3Ugd2lsbFxuICAgKiBuZWVkIHRvIG1ha2Ugc3VyZSBpdCBpcyB1cGRhdGVkIGV2ZXJ5IHRpbWUgdGhlIGFzc2V0IGNoYW5nZXMsIG9yIG90aGVyd2lzZSBpdCBpc1xuICAgKiBwb3NzaWJsZSB0aGF0IHNvbWUgZGVwbG95bWVudHMgd2lsbCBub3QgYmUgaW52YWxpZGF0ZWQuXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gYmFzZWQgb24gYGFzc2V0SGFzaFR5cGVgXG4gICAqL1xuICByZWFkb25seSBhc3NldEhhc2g/OiBzdHJpbmc7XG5cbiAgcmVhZG9ubHkgaW5zdGFsbENvbW1hbmRzPzogc3RyaW5nW107XG59XG5cbi8qKlxuICogUHJvZHVjZSBidW5kbGVkIExhbWJkYSBhc3NldCBjb2RlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidW5kbGUob3B0aW9uczogQnVuZGxpbmdPcHRpb25zKTogbGFtYmRhLkFzc2V0Q29kZSB7XG4gIGNvbnN0IHsgZW50cnksIHJ1bnRpbWUsIG91dHB1dFBhdGhTdWZmaXgsIGluc3RhbGxDb21tYW5kcyB9ID0gb3B0aW9ucztcblxuICBjb25zdCBzdGFnZWRpciA9IGNkay5GaWxlU3lzdGVtLm1rZHRlbXAoXCJweXRob24tYnVuZGxpbmctXCIpO1xuICBjb25zdCBoYXNEZXBzID0gc3RhZ2VEZXBlbmRlbmNpZXMoZW50cnksIHN0YWdlZGlyKTtcbiAgY29uc3QgaGFzSW5zdGFsbENvbW1hbmRzID0gc3RhZ2VJbnN0YWxsQ29tbWFuZHMoXG4gICAgaW5zdGFsbENvbW1hbmRzIHx8IFtdLFxuICAgIHN0YWdlZGlyXG4gICk7XG5cbiAgY29uc3QgZGVwc0NvbW1hbmQgPSBjaGFpbihbXG4gICAgaGFzRGVwcyB8fCBoYXNJbnN0YWxsQ29tbWFuZHNcbiAgICAgID8gYHJzeW5jIC1yICR7QlVORExFUl9ERVBFTkRFTkNJRVNfQ0FDSEV9Ly4gJHtjZGsuQXNzZXRTdGFnaW5nLkJVTkRMSU5HX09VVFBVVF9ESVJ9LyR7b3V0cHV0UGF0aFN1ZmZpeH1gXG4gICAgICA6IFwiXCIsXG4gICAgYHJzeW5jIC1yIC4gJHtjZGsuQXNzZXRTdGFnaW5nLkJVTkRMSU5HX09VVFBVVF9ESVJ9LyR7b3V0cHV0UGF0aFN1ZmZpeH1gLFxuICBdKTtcblxuICAvLyBEZXRlcm1pbmUgd2hpY2ggZG9ja2VyZmlsZSB0byB1c2UuIFdoZW4gZGVwZW5kZW5jaWVzIGFyZSBwcmVzZW50LCB3ZSB1c2UgYVxuICAvLyBEb2NrZXJmaWxlIHRoYXQgY2FuIGNyZWF0ZSBhIGNhY2hlYWJsZSBsYXllci4gV2UgY2FuJ3QgdXNlIHRoaXMgRG9ja2VyZmlsZVxuICAvLyBpZiB0aGVyZSBhcmVuJ3QgZGVwZW5kZW5jaWVzIG9yIHRoZSBEb2NrZXJmaWxlIHdpbGwgY29tcGxhaW4gYWJvdXQgbWlzc2luZ1xuICAvLyBzb3VyY2VzLlxuICBjb25zdCBkb2NrZXJmaWxlID0gaGFzSW5zdGFsbENvbW1hbmRzXG4gICAgPyBcIkRvY2tlcmZpbGUuY3VzdG9tXCJcbiAgICA6IGhhc0RlcHNcbiAgICA/IFwiRG9ja2VyZmlsZS5kZXBlbmRlbmNpZXNcIlxuICAgIDogXCJEb2NrZXJmaWxlXCI7XG5cbiAgLy8gY29weSBEb2NrZXJmaWxlIHRvIHdvcmtkaXJcbiAgZnMuY29weUZpbGVTeW5jKFxuICAgIHBhdGguam9pbihfX2Rpcm5hbWUsIFwiLi4vLi4vLi4vYXNzZXRzL3B5dGhvblwiLCBkb2NrZXJmaWxlKSxcbiAgICBwYXRoLmpvaW4oc3RhZ2VkaXIsIGRvY2tlcmZpbGUpXG4gICk7XG5cbiAgY29uc3QgaW1hZ2UgPSBjZGsuQnVuZGxpbmdEb2NrZXJJbWFnZS5mcm9tQXNzZXQoc3RhZ2VkaXIsIHtcbiAgICBidWlsZEFyZ3M6IHtcbiAgICAgIElNQUdFOiBydW50aW1lLmJ1bmRsaW5nRG9ja2VySW1hZ2UuaW1hZ2UsXG4gICAgfSxcbiAgICBmaWxlOiBkb2NrZXJmaWxlLFxuICB9KTtcblxuICByZXR1cm4gbGFtYmRhLkNvZGUuZnJvbUFzc2V0KGVudHJ5LCB7XG4gICAgYXNzZXRIYXNoVHlwZTogb3B0aW9ucy5hc3NldEhhc2hUeXBlLFxuICAgIGFzc2V0SGFzaDogb3B0aW9ucy5hc3NldEhhc2gsXG4gICAgZXhjbHVkZTogREVQRU5ERU5DWV9FWENMVURFUyxcbiAgICBidW5kbGluZzoge1xuICAgICAgaW1hZ2UsXG4gICAgICBjb21tYW5kOiBbXCJiYXNoXCIsIFwiLWNcIiwgZGVwc0NvbW1hbmRdLFxuICAgIH0sXG4gIH0pO1xufVxuXG4vKipcbiAqIENoZWNrcyB0byBzZWUgaWYgdGhlIGBlbnRyeWAgZGlyZWN0b3J5IGNvbnRhaW5zIGEgdHlwZSBvZiBkZXBlbmRlbmN5IHRoYXRcbiAqIHdlIGtub3cgaG93IHRvIGluc3RhbGwuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdGFnZURlcGVuZGVuY2llcyhlbnRyeTogc3RyaW5nLCBzdGFnZWRpcjogc3RyaW5nKTogYm9vbGVhbiB7XG4gIGNvbnN0IHByZWZpeGVzID0gW1wiUGlwZmlsZVwiLCBcInB5cHJvamVjdFwiLCBcInBvZXRyeVwiLCBcInJlcXVpcmVtZW50cy50eHRcIl07XG5cbiAgbGV0IGZvdW5kID0gZmFsc2U7XG4gIGZvciAoY29uc3QgZmlsZSBvZiBmcy5yZWFkZGlyU3luYyhlbnRyeSkpIHtcbiAgICBmb3IgKGNvbnN0IHByZWZpeCBvZiBwcmVmaXhlcykge1xuICAgICAgaWYgKGZpbGUuc3RhcnRzV2l0aChwcmVmaXgpKSB7XG4gICAgICAgIGZzLmNvcHlGaWxlU3luYyhwYXRoLmpvaW4oZW50cnksIGZpbGUpLCBwYXRoLmpvaW4oc3RhZ2VkaXIsIGZpbGUpKTtcbiAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmb3VuZDtcbn1cblxuZnVuY3Rpb24gc3RhZ2VJbnN0YWxsQ29tbWFuZHMoXG4gIGluc3RhbGxDb21tYW5kczogc3RyaW5nW10sXG4gIHN0YWdlZGlyOiBzdHJpbmdcbik6IGJvb2xlYW4ge1xuICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgaWYgKGluc3RhbGxDb21tYW5kcy5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgZmlsZVBhdGggPSBwYXRoLmpvaW4oc3RhZ2VkaXIsIFwic3N0LWRlcHMtaW5zdGFsbC1jb21tYW5kLnNoXCIpO1xuICAgIGZzLndyaXRlRmlsZVN5bmMoZmlsZVBhdGgsIGluc3RhbGxDb21tYW5kcy5qb2luKFwiICYmIFwiKSk7XG4gICAgZnMuY2htb2RTeW5jKGZpbGVQYXRoLCBcIjc1NVwiKTtcbiAgICBmb3VuZCA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gZm91bmQ7XG59XG5cbmZ1bmN0aW9uIGNoYWluKGNvbW1hbmRzOiBzdHJpbmdbXSk6IHN0cmluZyB7XG4gIHJldHVybiBjb21tYW5kcy5maWx0ZXIoKGMpID0+ICEhYykuam9pbihcIiAmJiBcIik7XG59XG4iXX0=