"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const AWS = __importStar(require("aws-sdk"));
AWS.config.logger = console;
const util_1 = require("./util");
const cfnResponse = __importStar(require("./cfn-response"));
const lambda = new AWS.Lambda({ region: "us-east-1" });
const LIVE_ALIAS = "live";
function handler(cfnRequest) {
    return __awaiter(this, void 0, void 0, function* () {
        (0, util_1.log)("onEventHandler", cfnRequest);
        // Process request
        let PhysicalResourceId;
        let Data;
        const functionArn = cfnRequest.ResourceProperties.FunctionArn;
        const functionName = functionArn.split(":").pop();
        switch (cfnRequest.RequestType) {
            case "Create": {
                const ret = yield createVersion(functionName);
                const version = ret.Version;
                yield createAlias(functionName, version);
                PhysicalResourceId = `${functionArn}:${version}`;
                Data = { Version: version };
                break;
            }
            case "Update": {
                PhysicalResourceId = cfnRequest.PhysicalResourceId;
                Data = { Version: cfnRequest.PhysicalResourceId.split(":").pop() };
                break;
            }
            case "Delete": {
                yield deleteOldVersions(functionName);
                PhysicalResourceId = cfnRequest.PhysicalResourceId;
                break;
            }
            default:
                throw new Error("Unsupported request type");
        }
        // Build response
        return cfnResponse.submitResponse("SUCCESS", Object.assign(Object.assign({}, cfnRequest), { PhysicalResourceId,
            Data }));
    });
}
function createVersion(functionName) {
    return __awaiter(this, void 0, void 0, function* () {
        (0, util_1.log)(`createVersion() called with functionName`, functionName);
        const resp = yield lambda
            .publishVersion({
            FunctionName: functionName,
        })
            .promise();
        (0, util_1.log)(`response`, resp);
        return { Version: resp.Version };
    });
}
function createAlias(functionName, version) {
    return __awaiter(this, void 0, void 0, function* () {
        (0, util_1.log)(`createAlias() called with functionName`, functionName, "version", version);
        let resp;
        // Update alias
        try {
            (0, util_1.log)("updateAlias");
            resp = yield lambda
                .updateAlias({
                Name: LIVE_ALIAS,
                FunctionName: functionName,
                FunctionVersion: version,
            })
                .promise();
            (0, util_1.log)("response", resp);
        }
        catch (e) {
            // If alias has not be created, create the alias
            if (e.code === "ResourceNotFoundException" &&
                e.message.startsWith("Alias not found")) {
                (0, util_1.log)("updateAlias");
                resp = yield lambda
                    .createAlias({
                    Name: LIVE_ALIAS,
                    FunctionName: functionName,
                    FunctionVersion: version,
                })
                    .promise();
                (0, util_1.log)("response", resp);
                return;
            }
            throw e;
        }
    });
}
function deleteOldVersions(functionName) {
    return __awaiter(this, void 0, void 0, function* () {
        (0, util_1.log)(`deleteOldVersions() called with functionName`, functionName);
        let resp;
        try {
            // Get LIVE_ALIAS version
            resp = yield lambda
                .getAlias({
                FunctionName: functionName,
                Name: LIVE_ALIAS,
            })
                .promise();
            (0, util_1.log)(`getAlias`, resp);
            const liveVersion = resp.FunctionVersion;
            // Get all versions
            resp = yield lambda
                .listVersionsByFunction({
                FunctionName: functionName,
                MaxItems: 50,
            })
                .promise();
            (0, util_1.log)(`listVersionsByFunction`, resp);
            const versionObjs = resp.Versions || [];
            // Remove non LIVE_ALIAS versions
            for (let i = 0, l = versionObjs.length; i < l; i++) {
                const version = versionObjs[i].Version;
                if (version === liveVersion) {
                    (0, util_1.log)("deleteVersion", version, "skipped");
                    continue;
                }
                try {
                    (0, util_1.log)("deleteVersion", version, "do");
                    resp = yield lambda
                        .deleteFunction({
                        FunctionName: functionName,
                        Qualifier: version,
                    })
                        .promise();
                    (0, util_1.log)("response", resp);
                }
                catch (e) {
                    // Supress error because a version can fail to remove if still in use.
                    (0, util_1.log)(`deleteVersion error`, e);
                }
            }
        }
        catch (e) {
            // Supress error because it is fine if a specific version fails to remove.
            // All versions will be removed upon removing the function.
            (0, util_1.log)(`deleteOldVersions error`, e);
        }
    });
}
module.exports = {
    handler: cfnResponse.safeHandler(handler),
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZWRnZS1sYW1iZGEtdmVyc2lvbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9uZXh0anMtc2l0ZS9jdXN0b20tcmVzb3VyY2UvZWRnZS1sYW1iZGEtdmVyc2lvbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLDZDQUErQjtBQUMvQixHQUFHLENBQUMsTUFBTSxDQUFDLE1BQU0sR0FBRyxPQUFPLENBQUM7QUFFNUIsaUNBQTZCO0FBQzdCLDREQUE4QztBQUM5QyxNQUFNLE1BQU0sR0FBRyxJQUFJLEdBQUcsQ0FBQyxNQUFNLENBQUMsRUFBRSxNQUFNLEVBQUUsV0FBVyxFQUFFLENBQUMsQ0FBQztBQUN2RCxNQUFNLFVBQVUsR0FBRyxNQUFNLENBQUM7QUFNMUIsU0FBZSxPQUFPLENBQ3BCLFVBQXVEOztRQUV2RCxJQUFBLFVBQUcsRUFBQyxnQkFBZ0IsRUFBRSxVQUFVLENBQUMsQ0FBQztRQUVsQyxrQkFBa0I7UUFDbEIsSUFBSSxrQkFBa0IsQ0FBQztRQUN2QixJQUFJLElBQUksQ0FBQztRQUNULE1BQU0sV0FBVyxHQUFHLFVBQVUsQ0FBQyxrQkFBa0IsQ0FBQyxXQUFXLENBQUM7UUFDOUQsTUFBTSxZQUFZLEdBQUcsV0FBVyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUNsRCxRQUFRLFVBQVUsQ0FBQyxXQUFXLEVBQUU7WUFDOUIsS0FBSyxRQUFRLENBQUMsQ0FBQztnQkFDYixNQUFNLEdBQUcsR0FBRyxNQUFNLGFBQWEsQ0FBQyxZQUFZLENBQUMsQ0FBQztnQkFDOUMsTUFBTSxPQUFPLEdBQUcsR0FBRyxDQUFDLE9BQWlCLENBQUM7Z0JBQ3RDLE1BQU0sV0FBVyxDQUFDLFlBQVksRUFBRSxPQUFPLENBQUMsQ0FBQztnQkFDekMsa0JBQWtCLEdBQUcsR0FBRyxXQUFXLElBQUksT0FBTyxFQUFFLENBQUM7Z0JBQ2pELElB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LFVBQUcsRUFBQyxxQkFBcUIsRUFBRSxDQUFDLENBQUMsQ0FBQztpQkFDL0I7YUFDRjtTQUNGO1FBQUMsT0FBTyxDQUFDLEVBQUU7WUFDViwwRUFBMEU7WUFDMUUsMkRBQTJEO1lBQzNELElBQUEsVUFBRyxFQUFDLHlCQUF5QixFQUFFLENBQUMsQ0FBQyxDQUFDO1NBQ25DO0lBQ0gsQ0FBQztDQUFBO0FBM0pELGlCQUFTO0lBQ1AsT0FBTyxFQUFFLFdBQVcsQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDO0NBQzFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBBV1MgZnJvbSBcImF3cy1zZGtcIjtcbkFXUy5jb25maWcubG9nZ2VyID0gY29uc29sZTtcblxuaW1wb3J0IHsgbG9nIH0gZnJvbSBcIi4vdXRpbFwiO1xuaW1wb3J0ICogYXMgY2ZuUmVzcG9uc2UgZnJvbSBcIi4vY2ZuLXJlc3BvbnNlXCI7XG5jb25zdCBsYW1iZGEgPSBuZXcgQVdTLkxhbWJkYSh7IHJlZ2lvbjogXCJ1cy1lYXN0LTFcIiB9KTtcbmNvbnN0IExJVkVfQUxJQVMgPSBcImxpdmVcIjtcblxuZXhwb3J0ID0ge1xuICBoYW5kbGVyOiBjZm5SZXNwb25zZS5zYWZlSGFuZGxlcihoYW5kbGVyKSxcbn07XG5cbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZXIoXG4gIGNmblJlcXVlc3Q6IEFXU0xhbWJkYS5DbG91ZEZvcm1hdGlvbkN1c3RvbVJlc291cmNlRXZlbnRcbikge1xuICBsb2coXCJvbkV2ZW50SGFuZGxlclwiLCBjZm5SZXF1ZXN0KTtcblxuICAvLyBQcm9jZXNzIHJlcXVlc3RcbiAgbGV0IFBoeXNpY2FsUmVzb3VyY2VJZDtcbiAgbGV0IERhdGE7XG4gIGNvbnN0IGZ1bmN0aW9uQXJuID0gY2ZuUmVxdWVzdC5SZXNvdXJjZVByb3BlcnRpZXMuRnVuY3Rpb25Bcm47XG4gIGNvbnN0IGZ1bmN0aW9uTmFtZSA9IGZ1bmN0aW9uQXJuLnNwbGl0KFwiOlwiKS5wb3AoKTtcbiAgc3dpdGNoIChjZm5SZXF1ZXN0LlJlcXVlc3RUeXBlKSB7XG4gICAgY2FzZSBcIkNyZWF0ZVwiOiB7XG4gICAgICBjb25zdCByZXQgPSBhd2FpdCBjcmVhdGVWZXJzaW9uKGZ1bmN0aW9uTmFtZSk7XG4gICAgICBjb25zdCB2ZXJzaW9uID0gcmV0LlZlcnNpb24gYXMgc3RyaW5nO1xuICAgICAgYXdhaXQgY3JlYXRlQWxpYXMoZnVuY3Rpb25OYW1lLCB2ZXJzaW9uKTtcbiAgICAgIFBoeXNpY2FsUmVzb3VyY2VJZCA9IGAke2Z1bmN0aW9uQXJufToke3ZlcnNpb259YDtcbiAgICAgIERhdGEgPSB7IFZlcnNpb246IHZlcnNpb24gfTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiVXBkYXRlXCI6IHtcbiAgICAgIFBoeXNpY2FsUmVzb3VyY2VJZCA9IGNmblJlcXVlc3QuUGh5c2ljYWxSZXNvdXJjZUlkO1xuICAgICAgRGF0YSA9IHsgVmVyc2lvbjogY2ZuUmVxdWVzdC5QaHlzaWNhbFJlc291cmNlSWQuc3BsaXQoXCI6XCIpLnBvcCgpIH07XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcIkRlbGV0ZVwiOiB7XG4gICAgICBhd2FpdCBkZWxldGVPbGRWZXJzaW9ucyhmdW5jdGlvbk5hbWUpO1xuICAgICAgUGh5c2ljYWxSZXNvdXJjZUlkID0gY2ZuUmVxdWVzdC5QaHlzaWNhbFJlc291cmNlSWQ7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIHJlcXVlc3QgdHlwZVwiKTtcbiAgfVxuXG4gIC8vIEJ1aWxkIHJlc3BvbnNlXG4gIHJldHVybiBjZm5SZXNwb25zZS5zdWJtaXRSZXNwb25zZShcIlNVQ0NFU1NcIiwge1xuICAgIC4uLmNmblJlcXVlc3QsXG4gICAgUGh5c2ljYWxSZXNvdXJjZUlkLFxuICAgIERhdGEsXG4gIH0pO1xufVxuXG5hc3luYyBmdW5jdGlvbiBjcmVhdGVWZXJzaW9uKGZ1bmN0aW9uTmFtZTogc3RyaW5nKSB7XG4gIGxvZyhgY3JlYXRlVmVyc2lvbigpIGNhbGxlZCB3aXRoIGZ1bmN0aW9uTmFtZWAsIGZ1bmN0aW9uTmFtZSk7XG5cbiAgY29uc3QgcmVzcCA9IGF3YWl0IGxhbWJkYVxuICAgIC5wdWJsaXNoVmVyc2lvbih7XG4gICAgICBGdW5jdGlvbk5hbWU6IGZ1bmN0aW9uTmFtZSxcbiAgICB9KVxuICAgIC5wcm9taXNlKCk7XG5cbiAgbG9nKGByZXNwb25zZWAsIHJlc3ApO1xuXG4gIHJldHVybiB7IFZlcnNpb246IHJlc3AuVmVyc2lvbiB9O1xufVxuXG5hc3luYyBmdW5jdGlvbiBjcmVhdGVBbGlhcyhmdW5jdGlvbk5hbWU6IHN0cmluZywgdmVyc2lvbjogc3RyaW5nKSB7XG4gIGxvZyhcbiAgICBgY3JlYXRlQWxpYXMoKSBjYWxsZWQgd2l0aCBmdW5jdGlvbk5hbWVgLFxuICAgIGZ1bmN0aW9uTmFtZSxcbiAgICBcInZlcnNpb25cIixcbiAgICB2ZXJzaW9uXG4gICk7XG5cbiAgbGV0IHJlc3A7XG5cbiAgLy8gVXBkYXRlIGFsaWFzXG4gIHRyeSB7XG4gICAgbG9nKFwidXBkYXRlQWxpYXNcIik7XG4gICAgcmVzcCA9IGF3YWl0IGxhbWJkYVxuICAgICAgLnVwZGF0ZUFsaWFzKHtcbiAgICAgICAgTmFtZTogTElWRV9BTElBUyxcbiAgICAgICAgRnVuY3Rpb25OYW1lOiBmdW5jdGlvbk5hbWUsXG4gICAgICAgIEZ1bmN0aW9uVmVyc2lvbjogdmVyc2lvbixcbiAgICAgIH0pXG4gICAgICAucHJvbWlzZSgpO1xuXG4gICAgbG9nKFwicmVzcG9uc2VcIiwgcmVzcCk7XG4gIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgIC8vIElmIGFsaWFzIGhhcyBub3QgYmUgY3JlYXRlZCwgY3JlYXRlIHRoZSBhbGlhc1xuICAgIGlmIChcbiAgICAgIGUuY29kZSA9PT0gXCJSZXNvdXJjZU5vdEZvdW5kRXhjZXB0aW9uXCIgJiZcbiAgICAgIGUubWVzc2FnZS5zdGFydHNXaXRoKFwiQWxpYXMgbm90IGZvdW5kXCIpXG4gICAgKSB7XG4gICAgICBsb2coXCJ1cGRhdGVBbGlhc1wiKTtcbiAgICAgIHJlc3AgPSBhd2FpdCBsYW1iZGFcbiAgICAgICAgLmNyZWF0ZUFsaWFzKHtcbiAgICAgICAgICBOYW1lOiBMSVZFX0FMSUFTLFxuICAgICAgICAgIEZ1bmN0aW9uTmFtZTogZnVuY3Rpb25OYW1lLFxuICAgICAgICAgIEZ1bmN0aW9uVmVyc2lvbjogdmVyc2lvbixcbiAgICAgICAgfSlcbiAgICAgICAgLnByb21pc2UoKTtcblxuICAgICAgbG9nKFwicmVzcG9uc2VcIiwgcmVzcCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRocm93IGU7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gZGVsZXRlT2xkVmVyc2lvbnMoZnVuY3Rpb25OYW1lOiBzdHJpbmcpIHtcbiAgbG9nKGBkZWxldGVPbGRWZXJzaW9ucygpIGNhbGxlZCB3aXRoIGZ1bmN0aW9uTmFtZWAsIGZ1bmN0aW9uTmFtZSk7XG5cbiAgbGV0IHJlc3A7XG4gIHRyeSB7XG4gICAgLy8gR2V0IExJVkVfQUxJQVMgdmVyc2lvblxuICAgIHJlc3AgPSBhd2FpdCBsYW1iZGFcbiAgICAgIC5nZXRBbGlhcyh7XG4gICAgICAgIEZ1bmN0aW9uTmFtZTogZnVuY3Rpb25OYW1lLFxuICAgICAgICBOYW1lOiBMSVZFX0FMSUFTLFxuICAgICAgfSlcbiAgICAgIC5wcm9taXNlKCk7XG4gICAgbG9nKGBnZXRBbGlhc2AsIHJlc3ApO1xuICAgIGNvbnN0IGxpdmVWZXJzaW9uID0gcmVzcC5GdW5jdGlvblZlcnNpb247XG5cbiAgICAvLyBHZXQgYWxsIHZlcnNpb25zXG4gICAgcmVzcCA9IGF3YWl0IGxhbWJkYVxuICAgICAgLmxpc3RWZXJzaW9uc0J5RnVuY3Rpb24oe1xuICAgICAgICBGdW5jdGlvbk5hbWU6IGZ1bmN0aW9uTmFtZSxcbiAgICAgICAgTWF4SXRlbXM6IDUwLFxuICAgICAgfSlcbiAgICAgIC5wcm9taXNlKCk7XG4gICAgbG9nKGBsaXN0VmVyc2lvbnNCeUZ1bmN0aW9uYCwgcmVzcCk7XG4gICAgY29uc3QgdmVyc2lvbk9ianMgPSByZXNwLlZlcnNpb25zIHx8IFtdO1xuXG4gICAgLy8gUmVtb3ZlIG5vbiBMSVZFX0FMSUFTIHZlcnNpb25zXG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSB2ZXJzaW9uT2Jqcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGNvbnN0IHZlcnNpb24gPSB2ZXJzaW9uT2Jqc1tpXS5WZXJzaW9uO1xuICAgICAgaWYgKHZlcnNpb24gPT09IGxpdmVWZXJzaW9uKSB7XG4gICAgICAgIGxvZyhcImRlbGV0ZVZlcnNpb25cIiwgdmVyc2lvbiwgXCJza2lwcGVkXCIpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgbG9nKFwiZGVsZXRlVmVyc2lvblwiLCB2ZXJzaW9uLCBcImRvXCIpO1xuICAgICAgICByZXNwID0gYXdhaXQgbGFtYmRhXG4gICAgICAgICAgLmRlbGV0ZUZ1bmN0aW9uKHtcbiAgICAgICAgICAgIEZ1bmN0aW9uTmFtZTogZnVuY3Rpb25OYW1lLFxuICAgICAgICAgICAgUXVhbGlmaWVyOiB2ZXJzaW9uLFxuICAgICAgICAgIH0pXG4gICAgICAgICAgLnByb21pc2UoKTtcbiAgICAgICAgbG9nKFwicmVzcG9uc2VcIiwgcmVzcCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIFN1cHJlc3MgZXJyb3IgYmVjYXVzZSBhIHZlcnNpb24gY2FuIGZhaWwgdG8gcmVtb3ZlIGlmIHN0aWxsIGluIHVzZS5cbiAgICAgICAgbG9nKGBkZWxldGVWZXJzaW9uIGVycm9yYCwgZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gU3VwcmVzcyBlcnJvciBiZWNhdXNlIGl0IGlzIGZpbmUgaWYgYSBzcGVjaWZpYyB2ZXJzaW9uIGZhaWxzIHRvIHJlbW92ZS5cbiAgICAvLyBBbGwgdmVyc2lvbnMgd2lsbCBiZSByZW1vdmVkIHVwb24gcmVtb3ZpbmcgdGhlIGZ1bmN0aW9uLlxuICAgIGxvZyhgZGVsZXRlT2xkVmVyc2lvbnMgZXJyb3JgLCBlKTtcbiAgfVxufVxuIl19