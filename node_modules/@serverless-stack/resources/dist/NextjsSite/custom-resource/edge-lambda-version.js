"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const AWS = __importStar(require("aws-sdk"));
AWS.config.logger = console;
const util_1 = require("./util");
const cfnResponse = __importStar(require("./cfn-response"));
const lambda = new AWS.Lambda({ region: "us-east-1" });
function handler(cfnRequest) {
    return __awaiter(this, void 0, void 0, function* () {
        (0, util_1.log)("onEventHandler", cfnRequest);
        // Process request
        let PhysicalResourceId;
        let Data;
        const functionArn = cfnRequest.ResourceProperties.FunctionArn;
        const functionName = functionArn.split(":").pop();
        switch (cfnRequest.RequestType) {
            case 'Create':
                const ret = yield createVersion(functionName);
                PhysicalResourceId = `${functionArn}:${ret.Version}`;
                Data = { Version: ret.Version };
                break;
            case 'Update':
                PhysicalResourceId = cfnRequest.PhysicalResourceId;
                Data = { Version: cfnRequest.PhysicalResourceId.split(":").pop() };
                break;
            case 'Delete':
                const version = cfnRequest.PhysicalResourceId.split(":").pop();
                yield deleteVersion(functionName, version);
                PhysicalResourceId = cfnRequest.PhysicalResourceId;
                break;
            default:
                throw new Error("Unsupported request type");
        }
        // Build response
        return cfnResponse.submitResponse("SUCCESS", Object.assign(Object.assign({}, cfnRequest), { PhysicalResourceId,
            Data }));
    });
}
function createVersion(functionName) {
    return __awaiter(this, void 0, void 0, function* () {
        (0, util_1.log)(`createVersion() called with functionName`, functionName);
        const resp = yield lambda
            .publishVersion({
            FunctionName: functionName,
        })
            .promise();
        (0, util_1.log)(`response`, resp);
        return { Version: resp.Version };
    });
}
function deleteVersion(functionName, version) {
    return __awaiter(this, void 0, void 0, function* () {
        (0, util_1.log)(`deleteVersion() called with functionName`, functionName, `version`, version);
        const resp = yield lambda.deleteFunction({
            FunctionName: functionName,
            Qualifier: version,
        }).promise();
        (0, util_1.log)(`response`, resp);
    });
}
module.exports = {
    handler: cfnResponse.safeHandler(handler),
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZWRnZS1sYW1iZGEtdmVyc2lvbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9OZXh0anNTaXRlL2N1c3RvbS1yZXNvdXJjZS9lZGdlLWxhbWJkYS12ZXJzaW9uLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsNkNBQStCO0FBQy9CLEdBQUcsQ0FBQyxNQUFNLENBQUMsTUFBTSxHQUFHLE9BQU8sQ0FBQztBQUU1QixpQ0FBNkI7QUFDN0IsNERBQThDO0FBQzlDLE1BQU0sTUFBTSxHQUFHLElBQUksR0FBRyxDQUFDLE1BQU0sQ0FBQyxFQUFFLE1BQU0sRUFBRSxXQUFXLEVBQUUsQ0FBQyxDQUFDO0FBTXZELFNBQWUsT0FBTyxDQUNwQixVQUF1RDs7UUFFdkQsSUFBQSxVQUFHLEVBQUMsZ0JBQWdCLEVBQUUsVUFBVSxDQUFDLENBQUM7UUFFbEMsa0JBQWtCO1FBQ2xCLElBQUksa0JBQWtCLENBQUM7UUFDdkIsSUFBSSxJQUFJLENBQUM7UUFDVCxNQUFNLFdBQVcsR0FBRyxVQUFVLENBQUMsa0JBQWtCLENBQUMsV0FBVyxDQUFDO1FBQzlELE1BQU0sWUFBWSxHQUFHLFdBQVcsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUM7UUFDbEQsUUFBUSxVQUFVLENBQUMsV0FBVyxFQUFFO1lBQzlCLEtBQUssUUFBUTtnQkFDWCxNQUFNLEdBQUcsR0FBRyxNQUFNLGFBQWEsQ0FBQyxZQUFZLENBQUMsQ0FBQztnQkFDOUMsa0JBQWtCLEdBQUcsR0FBRyxXQUFXLElBQUksR0FBRyxDQUFDLE9BQU8sRUFBRSxDQUFDO2dCQUNyRCxJQUFJLEdBQUcsRUFBRSxPQUFPLEVBQUUsR0FBRyxDQUFDLE9BQU8sRUFBRSxDQUFDO2dCQUNoQyxNQUFNO1lBQ1IsS0FBSyxRQUFRO2dCQUNYLGtCQUFrQixHQUFHLFVBQVUsQ0FBQyxrQkFBa0IsQ0FBQztnQkFDbkQsSUFBSSxHQUFHLEVBQUUsT0FBTyxFQUFFLFVBQVUsQ0FBQyxrQkFBa0IsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQztnQkFDbkUsTUFBTTtZQUNSLEtBQUssUUFBUTtnQkFDWCxNQUFNLE9BQU8sR0FBRyxVQUFVLENBQUMsa0JBQWtCLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsRUFBWSxDQUFDO2dCQUN6RSxNQUFNLGFBQWEsQ0FBQyxZQUFZLEVBQUUsT0FBTyxDQUFDLENBQUM7Z0JBQzNDLGtCQUFrQixHQUFHLFVBQVUsQ0FBQyxrQkFBa0IsQ0FBQztnQkFDbkQsTUFBTTtZQUNSO2dCQUNFLE1BQU0sSUFBSSxLQUFLLENBQUMsMEJBQTBCLENBQUMsQ0FBQztTQUMvQztRQUVELGlCQUFpQjtRQUNqQixPQUFPLFdBQVcsQ0FBQyxjQUFjLENBQUMsU0FBUyxrQ0FDdEMsVUFBVSxLQUNiLGtCQUFrQjtZQUNsQixJQUFJLElBQ0osQ0FBQztJQUNMLENBQUM7Q0FBQTtBQUVELFNBQWUsYUFBYSxDQUFDLFlBQW9COztRQUMvQyxJQUFBLFVBQUcsRUFBQywwQ0FBMEMsRUFBRSxZQUFZLENBQUMsQ0FBQztRQUU5RCxNQUFNLElBQUksR0FBRyxNQUFNLE1BQU07YUFDdEIsY0FBYyxDQUFDO1lBQ2QsWUFBWSxFQUFFLFlBQVk7U0FDM0IsQ0FBQzthQUNELE9BQU8sRUFBRSxDQUFDO1FBRWIsSUFBQSxVQUFHLEVBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxDQUFDO1FBRXRCLE9BQU8sRUFBRSxPQUFPLEVBQUUsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDO0lBQ25DLENBQUM7Q0FBQTtBQUVELFNBQWUsYUFBYSxDQUFDLFlBQW9CLEVBQUUsT0FBZTs7UUFDaEUsSUFBQSxVQUFHLEVBQUMsMENBQTBDLEVBQUUsWUFBWSxFQUFFLFNBQVMsRUFBRSxPQUFPLENBQUMsQ0FBQztRQUVsRixNQUFNLElBQUksR0FBRyxNQUFNLE1BQU0sQ0FBQyxjQUFjLENBQUM7WUFDdkMsWUFBWSxFQUFFLFlBQVk7WUFDMUIsU0FBUyxFQUFFLE9BQU87U0FDbkIsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBRWIsSUFBQSxVQUFHLEVBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQ3hCLENBQUM7Q0FBQTtBQWhFRCxpQkFBUztJQUNQLE9BQU8sRUFBRSxXQUFXLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQztDQUMxQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgQVdTIGZyb20gXCJhd3Mtc2RrXCI7XG5BV1MuY29uZmlnLmxvZ2dlciA9IGNvbnNvbGU7XG5cbmltcG9ydCB7IGxvZyB9IGZyb20gXCIuL3V0aWxcIjtcbmltcG9ydCAqIGFzIGNmblJlc3BvbnNlIGZyb20gXCIuL2Nmbi1yZXNwb25zZVwiO1xuY29uc3QgbGFtYmRhID0gbmV3IEFXUy5MYW1iZGEoeyByZWdpb246IFwidXMtZWFzdC0xXCIgfSk7XG5cbmV4cG9ydCA9IHtcbiAgaGFuZGxlcjogY2ZuUmVzcG9uc2Uuc2FmZUhhbmRsZXIoaGFuZGxlciksXG59O1xuXG5hc3luYyBmdW5jdGlvbiBoYW5kbGVyKFxuICBjZm5SZXF1ZXN0OiBBV1NMYW1iZGEuQ2xvdWRGb3JtYXRpb25DdXN0b21SZXNvdXJjZUV2ZW50XG4pIHtcbiAgbG9nKFwib25FdmVudEhhbmRsZXJcIiwgY2ZuUmVxdWVzdCk7XG5cbiAgLy8gUHJvY2VzcyByZXF1ZXN0XG4gIGxldCBQaHlzaWNhbFJlc291cmNlSWQ7XG4gIGxldCBEYXRhO1xuICBjb25zdCBmdW5jdGlvbkFybiA9IGNmblJlcXVlc3QuUmVzb3VyY2VQcm9wZXJ0aWVzLkZ1bmN0aW9uQXJuO1xuICBjb25zdCBmdW5jdGlvbk5hbWUgPSBmdW5jdGlvbkFybi5zcGxpdChcIjpcIikucG9wKCk7XG4gIHN3aXRjaCAoY2ZuUmVxdWVzdC5SZXF1ZXN0VHlwZSkge1xuICAgIGNhc2UgJ0NyZWF0ZSc6XG4gICAgICBjb25zdCByZXQgPSBhd2FpdCBjcmVhdGVWZXJzaW9uKGZ1bmN0aW9uTmFtZSk7XG4gICAgICBQaHlzaWNhbFJlc291cmNlSWQgPSBgJHtmdW5jdGlvbkFybn06JHtyZXQuVmVyc2lvbn1gO1xuICAgICAgRGF0YSA9IHsgVmVyc2lvbjogcmV0LlZlcnNpb24gfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ1VwZGF0ZSc6XG4gICAgICBQaHlzaWNhbFJlc291cmNlSWQgPSBjZm5SZXF1ZXN0LlBoeXNpY2FsUmVzb3VyY2VJZDtcbiAgICAgIERhdGEgPSB7IFZlcnNpb246IGNmblJlcXVlc3QuUGh5c2ljYWxSZXNvdXJjZUlkLnNwbGl0KFwiOlwiKS5wb3AoKSB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnRGVsZXRlJzpcbiAgICAgIGNvbnN0IHZlcnNpb24gPSBjZm5SZXF1ZXN0LlBoeXNpY2FsUmVzb3VyY2VJZC5zcGxpdChcIjpcIikucG9wKCkgYXMgc3RyaW5nO1xuICAgICAgYXdhaXQgZGVsZXRlVmVyc2lvbihmdW5jdGlvbk5hbWUsIHZlcnNpb24pO1xuICAgICAgUGh5c2ljYWxSZXNvdXJjZUlkID0gY2ZuUmVxdWVzdC5QaHlzaWNhbFJlc291cmNlSWQ7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgcmVxdWVzdCB0eXBlXCIpO1xuICB9XG5cbiAgLy8gQnVpbGQgcmVzcG9uc2VcbiAgcmV0dXJuIGNmblJlc3BvbnNlLnN1Ym1pdFJlc3BvbnNlKFwiU1VDQ0VTU1wiLCB7XG4gICAgLi4uY2ZuUmVxdWVzdCxcbiAgICBQaHlzaWNhbFJlc291cmNlSWQsXG4gICAgRGF0YSxcbiAgfSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVZlcnNpb24oZnVuY3Rpb25OYW1lOiBzdHJpbmcpIHtcbiAgbG9nKGBjcmVhdGVWZXJzaW9uKCkgY2FsbGVkIHdpdGggZnVuY3Rpb25OYW1lYCwgZnVuY3Rpb25OYW1lKTtcblxuICBjb25zdCByZXNwID0gYXdhaXQgbGFtYmRhXG4gICAgLnB1Ymxpc2hWZXJzaW9uKHtcbiAgICAgIEZ1bmN0aW9uTmFtZTogZnVuY3Rpb25OYW1lLFxuICAgIH0pXG4gICAgLnByb21pc2UoKTtcblxuICBsb2coYHJlc3BvbnNlYCwgcmVzcCk7XG5cbiAgcmV0dXJuIHsgVmVyc2lvbjogcmVzcC5WZXJzaW9uIH07XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGRlbGV0ZVZlcnNpb24oZnVuY3Rpb25OYW1lOiBzdHJpbmcsIHZlcnNpb246IHN0cmluZykge1xuICBsb2coYGRlbGV0ZVZlcnNpb24oKSBjYWxsZWQgd2l0aCBmdW5jdGlvbk5hbWVgLCBmdW5jdGlvbk5hbWUsIGB2ZXJzaW9uYCwgdmVyc2lvbik7XG5cbiAgY29uc3QgcmVzcCA9IGF3YWl0IGxhbWJkYS5kZWxldGVGdW5jdGlvbih7XG4gICAgRnVuY3Rpb25OYW1lOiBmdW5jdGlvbk5hbWUsXG4gICAgUXVhbGlmaWVyOiB2ZXJzaW9uLFxuICB9KS5wcm9taXNlKCk7XG5cbiAgbG9nKGByZXNwb25zZWAsIHJlc3ApO1xufVxuXG4iXX0=