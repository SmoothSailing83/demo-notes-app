"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const AWS = __importStar(require("aws-sdk"));
AWS.config.logger = console;
const util_1 = require("./util");
const cfnResponse = __importStar(require("./cfn-response"));
const lambda = new AWS.Lambda({ region: "us-east-1" });
function handler(cfnRequest) {
    return __awaiter(this, void 0, void 0, function* () {
        (0, util_1.log)("onEventHandler", cfnRequest);
        // Process request
        let PhysicalResourceId;
        let Data;
        const functionArn = cfnRequest.ResourceProperties.FunctionArn;
        const functionName = functionArn.split(":").pop();
        switch (cfnRequest.RequestType) {
            case 'Create':
                const ret = yield createVersion(functionName);
                PhysicalResourceId = `${functionArn}:${ret.Version}`;
                Data = { Version: ret.Version };
                break;
            case 'Update':
                PhysicalResourceId = cfnRequest.PhysicalResourceId;
                Data = { Version: cfnRequest.PhysicalResourceId.split(":").pop() };
                break;
            case 'Delete':
                const version = cfnRequest.PhysicalResourceId.split(":").pop();
                yield deleteVersion(functionName, version);
                PhysicalResourceId = cfnRequest.PhysicalResourceId;
                break;
            default:
                throw new Error("Unsupported request type");
        }
        // Build response
        return cfnResponse.submitResponse("SUCCESS", Object.assign(Object.assign({}, cfnRequest), { PhysicalResourceId,
            Data }));
    });
}
function createVersion(functionName) {
    return __awaiter(this, void 0, void 0, function* () {
        (0, util_1.log)(`createVersion() called with functionName`, functionName);
        const resp = yield lambda
            .publishVersion({
            FunctionName: functionName,
        })
            .promise();
        (0, util_1.log)(`response`, resp);
        return { Version: resp.Version };
    });
}
function deleteVersion(functionName, version) {
    return __awaiter(this, void 0, void 0, function* () {
        (0, util_1.log)(`deleteVersion() called with functionName`, functionName, `version`, version);
        const resp = yield lambda.deleteFunction({
            FunctionName: functionName,
            Qualifier: version,
        }).promise();
        (0, util_1.log)(`response`, resp);
    });
}
module.exports = {
    handler: cfnResponse.safeHandler(handler),
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZWRnZS1sYW1iZGEtdmVyc2lvbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9OZXh0anNTaXRlL0N1c3RvbVJlc291cmNlL2VkZ2UtbGFtYmRhLXZlcnNpb24udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSw2Q0FBK0I7QUFDL0IsR0FBRyxDQUFDLE1BQU0sQ0FBQyxNQUFNLEdBQUcsT0FBTyxDQUFDO0FBRTVCLGlDQUE2QjtBQUM3Qiw0REFBOEM7QUFDOUMsTUFBTSxNQUFNLEdBQUcsSUFBSSxHQUFHLENBQUMsTUFBTSxDQUFDLEVBQUUsTUFBTSxFQUFFLFdBQVcsRUFBRSxDQUFDLENBQUM7QUFNdkQsU0FBZSxPQUFPLENBQ3BCLFVBQXVEOztRQUV2RCxJQUFBLFVBQUcsRUFBQyxnQkFBZ0IsRUFBRSxVQUFVLENBQUMsQ0FBQztRQUVsQyxrQkFBa0I7UUFDbEIsSUFBSSxrQkFBa0IsQ0FBQztRQUN2QixJQUFJLElBQUksQ0FBQztRQUNULE1BQU0sV0FBVyxHQUFHLFVBQVUsQ0FBQyxrQkFBa0IsQ0FBQyxXQUFXLENBQUM7UUFDOUQsTUFBTSxZQUFZLEdBQUcsV0FBVyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUNsRCxRQUFRLFVBQVUsQ0FBQyxXQUFXLEVBQUU7WUFDOUIsS0FBSyxRQUFRO2dCQUNYLE1BQU0sR0FBRyxHQUFHLE1BQU0sYUFBYSxDQUFDLFlBQVksQ0FBQyxDQUFDO2dCQUM5QyxrQkFBa0IsR0FBRyxHQUFHLFdBQVcsSUFBSSxHQUFHLENBQUMsT0FBTyxFQUFFLENBQUM7Z0JBQ3JELElBQUksR0FBRyxFQUFFLE9BQU8sRUFBRSxHQUFHLENBQUMsT0FBTyxFQUFFLENBQUM7Z0JBQ2hDLE1BQU07WUFDUixLQUFLLFFBQVE7Z0JBQ1gsa0JBQWtCLEdBQUcsVUFBVSxDQUFDLGtCQUFrQixDQUFDO2dCQUNuRCxJQUFJLEdBQUcsRUFBRSxPQUFPLEVBQUUsVUFBVSxDQUFDLGtCQUFrQixDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDO2dCQUNuRSxNQUFNO1lBQ1IsS0FBSyxRQUFRO2dCQUNYLE1BQU0sT0FBTyxHQUFHLFVBQVUsQ0FBQyxrQkFBa0IsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxFQUFZLENBQUM7Z0JBQ3pFLE1BQU0sYUFBYSxDQUFDLFlBQVksRUFBRSxPQUFPLENBQUMsQ0FBQztnQkFDM0Msa0JBQWtCLEdBQUcsVUFBVSxDQUFDLGtCQUFrQixDQUFDO2dCQUNuRCxNQUFNO1lBQ1I7Z0JBQ0UsTUFBTSxJQUFJLEtBQUssQ0FBQywwQkFBMEIsQ0FBQyxDQUFDO1NBQy9DO1FBRUQsaUJBQWlCO1FBQ2pCLE9BQU8sV0FBVyxDQUFDLGNBQWMsQ0FBQyxTQUFTLGtDQUN0QyxVQUFVLEtBQ2Isa0JBQWtCO1lBQ2xCLElBQUksSUFDSixDQUFDO0lBQ0wsQ0FBQztDQUFBO0FBRUQsU0FBZSxhQUFhLENBQUMsWUFBb0I7O1FBQy9DLElBQUEsVUFBRyxFQUFDLDBDQUEwQyxFQUFFLFlBQVksQ0FBQyxDQUFDO1FBRTlELE1BQU0sSUFBSSxHQUFHLE1BQU0sTUFBTTthQUN0QixjQUFjLENBQUM7WUFDZCxZQUFZLEVBQUUsWUFBWTtTQUMzQixDQUFDO2FBQ0QsT0FBTyxFQUFFLENBQUM7UUFFYixJQUFBLFVBQUcsRUFBQyxVQUFVLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFFdEIsT0FBTyxFQUFFLE9BQU8sRUFBRSxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7SUFDbkMsQ0FBQztDQUFBO0FBRUQsU0FBZSxhQUFhLENBQUMsWUFBb0IsRUFBRSxPQUFlOztRQUNoRSxJQUFBLFVBQUcsRUFBQywwQ0FBMEMsRUFBRSxZQUFZLEVBQUUsU0FBUyxFQUFFLE9BQU8sQ0FBQyxDQUFDO1FBRWxGLE1BQU0sSUFBSSxHQUFHLE1BQU0sTUFBTSxDQUFDLGNBQWMsQ0FBQztZQUN2QyxZQUFZLEVBQUUsWUFBWTtZQUMxQixTQUFTLEVBQUUsT0FBTztTQUNuQixDQUFDLENBQUMsT0FBTyxFQUFFLENBQUM7UUFFYixJQUFBLFVBQUcsRUFBQyxVQUFVLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDeEIsQ0FBQztDQUFBO0FBaEVELGlCQUFTO0lBQ1AsT0FBTyxFQUFFLFdBQVcsQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDO0NBQzFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBBV1MgZnJvbSBcImF3cy1zZGtcIjtcbkFXUy5jb25maWcubG9nZ2VyID0gY29uc29sZTtcblxuaW1wb3J0IHsgbG9nIH0gZnJvbSBcIi4vdXRpbFwiO1xuaW1wb3J0ICogYXMgY2ZuUmVzcG9uc2UgZnJvbSBcIi4vY2ZuLXJlc3BvbnNlXCI7XG5jb25zdCBsYW1iZGEgPSBuZXcgQVdTLkxhbWJkYSh7IHJlZ2lvbjogXCJ1cy1lYXN0LTFcIiB9KTtcblxuZXhwb3J0ID0ge1xuICBoYW5kbGVyOiBjZm5SZXNwb25zZS5zYWZlSGFuZGxlcihoYW5kbGVyKSxcbn07XG5cbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZXIoXG4gIGNmblJlcXVlc3Q6IEFXU0xhbWJkYS5DbG91ZEZvcm1hdGlvbkN1c3RvbVJlc291cmNlRXZlbnRcbikge1xuICBsb2coXCJvbkV2ZW50SGFuZGxlclwiLCBjZm5SZXF1ZXN0KTtcblxuICAvLyBQcm9jZXNzIHJlcXVlc3RcbiAgbGV0IFBoeXNpY2FsUmVzb3VyY2VJZDtcbiAgbGV0IERhdGE7XG4gIGNvbnN0IGZ1bmN0aW9uQXJuID0gY2ZuUmVxdWVzdC5SZXNvdXJjZVByb3BlcnRpZXMuRnVuY3Rpb25Bcm47XG4gIGNvbnN0IGZ1bmN0aW9uTmFtZSA9IGZ1bmN0aW9uQXJuLnNwbGl0KFwiOlwiKS5wb3AoKTtcbiAgc3dpdGNoIChjZm5SZXF1ZXN0LlJlcXVlc3RUeXBlKSB7XG4gICAgY2FzZSAnQ3JlYXRlJzpcbiAgICAgIGNvbnN0IHJldCA9IGF3YWl0IGNyZWF0ZVZlcnNpb24oZnVuY3Rpb25OYW1lKTtcbiAgICAgIFBoeXNpY2FsUmVzb3VyY2VJZCA9IGAke2Z1bmN0aW9uQXJufToke3JldC5WZXJzaW9ufWA7XG4gICAgICBEYXRhID0geyBWZXJzaW9uOiByZXQuVmVyc2lvbiB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnVXBkYXRlJzpcbiAgICAgIFBoeXNpY2FsUmVzb3VyY2VJZCA9IGNmblJlcXVlc3QuUGh5c2ljYWxSZXNvdXJjZUlkO1xuICAgICAgRGF0YSA9IHsgVmVyc2lvbjogY2ZuUmVxdWVzdC5QaHlzaWNhbFJlc291cmNlSWQuc3BsaXQoXCI6XCIpLnBvcCgpIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlICdEZWxldGUnOlxuICAgICAgY29uc3QgdmVyc2lvbiA9IGNmblJlcXVlc3QuUGh5c2ljYWxSZXNvdXJjZUlkLnNwbGl0KFwiOlwiKS5wb3AoKSBhcyBzdHJpbmc7XG4gICAgICBhd2FpdCBkZWxldGVWZXJzaW9uKGZ1bmN0aW9uTmFtZSwgdmVyc2lvbik7XG4gICAgICBQaHlzaWNhbFJlc291cmNlSWQgPSBjZm5SZXF1ZXN0LlBoeXNpY2FsUmVzb3VyY2VJZDtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCByZXF1ZXN0IHR5cGVcIik7XG4gIH1cblxuICAvLyBCdWlsZCByZXNwb25zZVxuICByZXR1cm4gY2ZuUmVzcG9uc2Uuc3VibWl0UmVzcG9uc2UoXCJTVUNDRVNTXCIsIHtcbiAgICAuLi5jZm5SZXF1ZXN0LFxuICAgIFBoeXNpY2FsUmVzb3VyY2VJZCxcbiAgICBEYXRhLFxuICB9KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gY3JlYXRlVmVyc2lvbihmdW5jdGlvbk5hbWU6IHN0cmluZykge1xuICBsb2coYGNyZWF0ZVZlcnNpb24oKSBjYWxsZWQgd2l0aCBmdW5jdGlvbk5hbWVgLCBmdW5jdGlvbk5hbWUpO1xuXG4gIGNvbnN0IHJlc3AgPSBhd2FpdCBsYW1iZGFcbiAgICAucHVibGlzaFZlcnNpb24oe1xuICAgICAgRnVuY3Rpb25OYW1lOiBmdW5jdGlvbk5hbWUsXG4gICAgfSlcbiAgICAucHJvbWlzZSgpO1xuXG4gIGxvZyhgcmVzcG9uc2VgLCByZXNwKTtcblxuICByZXR1cm4geyBWZXJzaW9uOiByZXNwLlZlcnNpb24gfTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZGVsZXRlVmVyc2lvbihmdW5jdGlvbk5hbWU6IHN0cmluZywgdmVyc2lvbjogc3RyaW5nKSB7XG4gIGxvZyhgZGVsZXRlVmVyc2lvbigpIGNhbGxlZCB3aXRoIGZ1bmN0aW9uTmFtZWAsIGZ1bmN0aW9uTmFtZSwgYHZlcnNpb25gLCB2ZXJzaW9uKTtcblxuICBjb25zdCByZXNwID0gYXdhaXQgbGFtYmRhLmRlbGV0ZUZ1bmN0aW9uKHtcbiAgICBGdW5jdGlvbk5hbWU6IGZ1bmN0aW9uTmFtZSxcbiAgICBRdWFsaWZpZXI6IHZlcnNpb24sXG4gIH0pLnByb21pc2UoKTtcblxuICBsb2coYHJlc3BvbnNlYCwgcmVzcCk7XG59XG5cbiJdfQ==