"use strict";
/* eslint-disable @typescript-eslint/ban-types*/
// Note: disabling ban-type rule so we don't get an error referencing the class Function
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Function = void 0;
const path_1 = __importDefault(require("path"));
const fs = __importStar(require("fs-extra"));
const cdk = __importStar(require("@aws-cdk/core"));
const iam = __importStar(require("@aws-cdk/aws-iam"));
const lambda = __importStar(require("@aws-cdk/aws-lambda"));
const ssm = __importStar(require("@aws-cdk/aws-ssm"));
const Stack_1 = require("./Stack");
const goBuilder_1 = require("./util/goBuilder");
const nodeBuilder_1 = require("./util/nodeBuilder");
const dotnetBuilder_1 = require("./util/dotnetBuilder");
const pythonBuilder_1 = require("./util/pythonBuilder");
const permission_1 = require("./util/permission");
const supportedRuntimes = [
    lambda.Runtime.NODEJS,
    lambda.Runtime.NODEJS_4_3,
    lambda.Runtime.NODEJS_6_10,
    lambda.Runtime.NODEJS_8_10,
    lambda.Runtime.NODEJS_10_X,
    lambda.Runtime.NODEJS_12_X,
    lambda.Runtime.NODEJS_14_X,
    lambda.Runtime.PYTHON_2_7,
    lambda.Runtime.PYTHON_3_6,
    lambda.Runtime.PYTHON_3_7,
    lambda.Runtime.PYTHON_3_8,
    lambda.Runtime.DOTNET_CORE_1,
    lambda.Runtime.DOTNET_CORE_2,
    lambda.Runtime.DOTNET_CORE_2_1,
    lambda.Runtime.DOTNET_CORE_3_1,
    lambda.Runtime.GO_1_X,
];
class Function extends lambda.Function {
    constructor(scope, id, props) {
        const root = scope.node.root;
        const stack = Stack_1.Stack.of(scope);
        // Merge with app defaultFunctionProps
        // note: reverse order so later prop override earlier ones
        stack.defaultFunctionProps
            .slice()
            .reverse()
            .forEach((per) => {
            props = Function.mergeProps(per, props);
        });
        // Set defaults
        const handler = props.handler;
        let timeout = props.timeout || 10;
        const srcPath = Function.normalizeSrcPath(props.srcPath || ".");
        const memorySize = props.memorySize || 1024;
        const tracing = props.tracing || lambda.Tracing.ACTIVE;
        let runtime = props.runtime || lambda.Runtime.NODEJS_12_X;
        let bundle = props.bundle;
        const permissions = props.permissions;
        const isLiveDevEnabled = props.enableLiveDev === false ? false : true;
        // Validate handler
        if (!handler) {
            throw new Error(`No handler defined for the "${id}" Lambda function`);
        }
        // Normalize runtime
        const runtimeStr = typeof runtime === "string" ? runtime : runtime.toString();
        const runtimeClass = supportedRuntimes.find((per) => per.toString() === runtimeStr);
        if (!runtimeClass) {
            throw new Error(`The specified runtime is not supported for sst.Function. Only NodeJS, Python, Go, and .NET runtimes are currently supported.`);
        }
        runtime = runtimeClass;
        // Normalize timeout
        if (typeof timeout === "number") {
            timeout = cdk.Duration.seconds(timeout);
        }
        // Validate input
        const isNodeRuntime = runtimeStr.startsWith("nodejs");
        const isGoRuntime = runtimeStr.startsWith("go");
        const isPythonRuntime = runtimeStr.startsWith("python");
        const isDotnetRuntime = runtimeStr.startsWith("dotnetcore");
        if (isNodeRuntime) {
            bundle = bundle === undefined ? true : props.bundle;
            if (!bundle && srcPath === ".") {
                throw new Error(`Bundle cannot be disabled for the "${id}" function since the "srcPath" is set to the project root. Read more here â€” https://github.com/serverless-stack/serverless-stack/issues/78`);
            }
        }
        else if (isPythonRuntime) {
            bundle = bundle === undefined ? {} : props.bundle;
            if (srcPath === ".") {
                throw new Error(`Cannot set the "srcPath" to the project root for the "${id}" function.`);
            }
        }
        // Handle local development (ie. sst start)
        // - set runtime to nodejs12.x for non-Node runtimes (b/c the stub is in Node)
        // - set retry to 0. When the debugger is disconnected, the Cron construct
        //   will still try to periodically invoke the Lambda, and the requests would
        //   fail and retry. So when launching `sst start`, a couple of retry requests
        //   from recent failed request will be received. And this behavior is confusing.
        if (isLiveDevEnabled &&
            root.local &&
            root.debugEndpoint &&
            root.debugBucketName &&
            root.debugBucketArn) {
            // If debugIncreaseTimeout is enabled:
            //   set timeout to 900. This will give people more time to debug the function
            //   without timing out the request. Note API Gateway requests have a maximum
            //   timeout of 29s. In this case, the API will timeout, but the Lambda function
            //   will continue to run.
            let debugOverrideProps;
            if (root.debugIncreaseTimeout) {
                debugOverrideProps = {
                    timeout: cdk.Duration.seconds(900),
                };
            }
            if (root.debugBridge) {
                super(scope, id, Object.assign(Object.assign(Object.assign({}, props), { runtime: lambda.Runtime.GO_1_X, tracing,
                    timeout,
                    memorySize, handler: "handler", code: lambda.Code.fromAsset(path_1.default.resolve(__dirname, "../dist/bridge_client/")), environment: Object.assign(Object.assign({}, (props.environment || {})), { SST_DEBUG_BRIDGE: root.debugBridge, SST_DEBUG_SRC_PATH: srcPath, SST_DEBUG_SRC_HANDLER: handler, SST_DEBUG_ENDPOINT: root.debugEndpoint }), layers: Function.handleImportedLayers(scope, props.layers || []) }), (debugOverrideProps || {})));
            }
            else {
                super(scope, id, Object.assign(Object.assign(Object.assign({}, props), { runtime: isNodeRuntime ? runtime : lambda.Runtime.NODEJS_12_X, tracing,
                    timeout,
                    memorySize, handler: "index.main", retryAttempts: 0, code: lambda.Code.fromAsset(path_1.default.resolve(__dirname, "../dist/stub.zip")), environment: Object.assign(Object.assign({}, (props.environment || {})), { SST_DEBUG_SRC_PATH: srcPath, SST_DEBUG_SRC_HANDLER: handler, SST_DEBUG_ENDPOINT: root.debugEndpoint, SST_DEBUG_BUCKET_NAME: root.debugBucketName }), layers: Function.handleImportedLayers(scope, props.layers || []) }), (debugOverrideProps || {})));
            }
            this.attachPermissions([
                new iam.PolicyStatement({
                    actions: ["s3:*"],
                    effect: iam.Effect.ALLOW,
                    resources: [root.debugBucketArn, `${root.debugBucketArn}/*`],
                }),
            ]);
        }
        // Handle remove (ie. sst remove)
        else if (root.skipBuild) {
            // Note: need to override runtime as CDK does not support inline code
            //       for some runtimes.
            super(scope, id, Object.assign(Object.assign({}, props), { runtime: lambda.Runtime.NODEJS_12_X, handler: "placeholder", code: lambda.Code.fromAsset(path_1.default.resolve(__dirname, "../assets/Function/placeholder-stub")), timeout, layers: Function.handleImportedLayers(scope, props.layers || []) }));
        }
        // Handle build
        else {
            let outCode, outHandler;
            if (isDotnetRuntime) {
                const ret = (0, dotnetBuilder_1.builder)({
                    srcPath,
                    handler,
                    buildDir: root.buildDir,
                    stack: Stack_1.Stack.of(scope).stackName,
                });
                outCode = ret.outCode;
                outHandler = ret.outHandler;
            }
            else if (isGoRuntime) {
                const ret = (0, goBuilder_1.builder)({
                    srcPath,
                    handler,
                    buildDir: root.buildDir,
                });
                outCode = ret.outCode;
                outHandler = ret.outHandler;
            }
            else if (isPythonRuntime) {
                const ret = (0, pythonBuilder_1.builder)({
                    bundle: bundle,
                    srcPath,
                    handler,
                    runtime,
                    stack: Stack_1.Stack.of(scope).stackName,
                });
                outCode = ret.outCode;
                outHandler = ret.outHandler;
            }
            else {
                const ret = (0, nodeBuilder_1.builder)({
                    bundle: bundle,
                    srcPath,
                    handler,
                    runtime,
                    buildDir: root.buildDir,
                    esbuildConfig: root.esbuildConfig,
                });
                outCode = ret.outCode;
                outHandler = ret.outHandler;
            }
            Function.copyFiles(bundle, srcPath, outCode.path);
            super(scope, id, Object.assign(Object.assign({}, props), { runtime,
                tracing,
                memorySize, handler: outHandler, code: outCode, timeout, layers: Function.handleImportedLayers(scope, props.layers || []) }));
        }
        // Enable reusing connections with Keep-Alive for NodeJs Lambda function
        if (isNodeRuntime) {
            this.addEnvironment("AWS_NODEJS_CONNECTION_REUSE_ENABLED", "1", {
                removeInEdge: true,
            });
        }
        // Attach permissions
        if (permissions) {
            this.attachPermissions(permissions);
        }
        // register Lambda function in app
        root.registerLambdaHandler({
            srcPath,
            handler,
            bundle,
            runtime: runtimeStr,
        });
        this._isLiveDevEnabled = isLiveDevEnabled;
    }
    attachPermissions(permissions) {
        if (this.role) {
            (0, permission_1.attachPermissionsToRole)(this.role, permissions);
        }
    }
    static normalizeSrcPath(srcPath) {
        return srcPath.replace(/\/+$/, "");
    }
    static copyFiles(bundle, srcPath, buildPath) {
        if (!bundle)
            return;
        if (typeof bundle === "boolean")
            return;
        if (!bundle.copyFiles)
            return;
        bundle.copyFiles.forEach((entry) => {
            const fromPath = path_1.default.join(srcPath, entry.from);
            if (!fs.existsSync(fromPath))
                throw new Error(`Tried to copy nonexistent file from "${path_1.default.resolve(fromPath)}" - check copyFiles entry "${entry.from}"`);
            const to = entry.to || entry.from;
            if (path_1.default.isAbsolute(to))
                throw new Error(`Copy destination path "${to}" must be relative`);
            const toPath = path_1.default.join(buildPath, to);
            fs.copySync(fromPath, toPath);
        });
    }
    static handleImportedLayers(scope, layers) {
        return layers.map((layer) => {
            const layerStack = Stack_1.Stack.of(layer);
            const currentStack = Stack_1.Stack.of(scope);
            // Use layer directly if:
            // - layer is created in the current stack; OR
            // - layer is imported (ie. layerArn is a string)
            if (layerStack === currentStack ||
                !cdk.Token.isUnresolved(layer.layerVersionArn)) {
                return layer;
            }
            // layer is created from another stack
            else {
                // set stack dependency b/c layerStack need to create the SSM first
                currentStack.addDependency(layerStack);
                // store layer ARN in SSM in layer's stack
                const parameterId = `${layer.node.id}Arn-${layer.node.addr}`;
                const parameterName = `/layers/${layerStack.node.id}/${parameterId}`;
                const existingSsmParam = layerStack.node.tryFindChild(parameterId);
                if (!existingSsmParam) {
                    new ssm.StringParameter(layerStack, parameterId, {
                        parameterName,
                        stringValue: layer.layerVersionArn,
                    });
                }
                // import layer from SSM value
                const layerId = `I${layer.node.id}-${layer.node.addr}`;
                const existingLayer = scope.node.tryFindChild(layerId);
                if (existingLayer) {
                    return existingLayer;
                }
                else {
                    return lambda.LayerVersion.fromLayerVersionArn(scope, layerId, ssm.StringParameter.valueForStringParameter(scope, parameterName));
                }
            }
        });
    }
    static fromDefinition(scope, id, definition, inheritedProps, inheritErrorMessage) {
        if (typeof definition === "string") {
            return new Function(scope, id, Object.assign(Object.assign({}, (inheritedProps || {})), { handler: definition }));
        }
        else if (definition instanceof Function) {
            if (inheritedProps && Object.keys(inheritedProps).length > 0) {
                throw new Error(inheritErrorMessage ||
                    `Cannot inherit default props when a Function is provided`);
            }
            return definition;
        }
        else if (definition instanceof lambda.Function) {
            throw new Error(`Please use sst.Function instead of lambda.Function for the "${id}" Function.`);
        }
        else if (definition.handler !== undefined) {
            return new Function(scope, id, Function.mergeProps(inheritedProps, definition));
        }
        throw new Error(`Invalid function definition for the "${id}" Function`);
    }
    static mergeProps(baseProps, props) {
        // Merge environment
        const environment = Object.assign(Object.assign({}, ((baseProps === null || baseProps === void 0 ? void 0 : baseProps.environment) || {})), ((props === null || props === void 0 ? void 0 : props.environment) || {}));
        const environmentProp = Object.keys(environment).length === 0 ? {} : { environment };
        // Merge layers
        const layers = [...((baseProps === null || baseProps === void 0 ? void 0 : baseProps.layers) || []), ...((props === null || props === void 0 ? void 0 : props.layers) || [])];
        const layersProp = layers.length === 0 ? {} : { layers };
        // Merge permissions
        let permissionsProp;
        if ((baseProps === null || baseProps === void 0 ? void 0 : baseProps.permissions) === permission_1.PermissionType.ALL ||
            (props === null || props === void 0 ? void 0 : props.permissions) === permission_1.PermissionType.ALL) {
            permissionsProp = { permissions: permission_1.PermissionType.ALL };
        }
        else {
            const permissions = ((baseProps === null || baseProps === void 0 ? void 0 : baseProps.permissions) || []).concat((props === null || props === void 0 ? void 0 : props.permissions) || []);
            permissionsProp = permissions.length === 0 ? {} : { permissions };
        }
        return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, (baseProps || {})), (props || {})), layersProp), environmentProp), permissionsProp);
    }
}
exports.Function = Function;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRnVuY3Rpb24uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvRnVuY3Rpb24udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLGdEQUFnRDtBQUNoRCx3RkFBd0Y7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFeEYsZ0RBQXdCO0FBRXhCLDZDQUErQjtBQUMvQixtREFBcUM7QUFDckMsc0RBQXdDO0FBQ3hDLDREQUE4QztBQUU5QyxzREFBd0M7QUFHeEMsbUNBQWdDO0FBQ2hDLGdEQUF3RDtBQUN4RCxvREFBNEQ7QUFDNUQsd0RBQWdFO0FBQ2hFLHdEQUFnRTtBQUNoRSxrREFJMkI7QUFFM0IsTUFBTSxpQkFBaUIsR0FBRztJQUN4QixNQUFNLENBQUMsT0FBTyxDQUFDLE1BQU07SUFDckIsTUFBTSxDQUFDLE9BQU8sQ0FBQyxVQUFVO0lBQ3pCLE1BQU0sQ0FBQyxPQUFPLENBQUMsV0FBVztJQUMxQixNQUFNLENBQUMsT0FBTyxDQUFDLFdBQVc7SUFDMUIsTUFBTSxDQUFDLE9BQU8sQ0FBQyxXQUFXO0lBQzFCLE1BQU0sQ0FBQyxPQUFPLENBQUMsV0FBVztJQUMxQixNQUFNLENBQUMsT0FBTyxDQUFDLFdBQVc7SUFDMUIsTUFBTSxDQUFDLE9BQU8sQ0FBQyxVQUFVO0lBQ3pCLE1BQU0sQ0FBQyxPQUFPLENBQUMsVUFBVTtJQUN6QixNQUFNLENBQUMsT0FBTyxDQUFDLFVBQVU7SUFDekIsTUFBTSxDQUFDLE9BQU8sQ0FBQyxVQUFVO0lBQ3pCLE1BQU0sQ0FBQyxPQUFPLENBQUMsYUFBYTtJQUM1QixNQUFNLENBQUMsT0FBTyxDQUFDLGFBQWE7SUFDNUIsTUFBTSxDQUFDLE9BQU8sQ0FBQyxlQUFlO0lBQzlCLE1BQU0sQ0FBQyxPQUFPLENBQUMsZUFBZTtJQUM5QixNQUFNLENBQUMsT0FBTyxDQUFDLE1BQU07Q0FDdEIsQ0FBQztBQXNIRixNQUFhLFFBQVMsU0FBUSxNQUFNLENBQUMsUUFBUTtJQUczQyxZQUFZLEtBQW9CLEVBQUUs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TUFBTSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLFdBQVcsRUFBRSxDQUFDO1NBQ25FO1FBRUQsaUZBQ0ssQ0FBQyxTQUFTLElBQUksRUFBRSxDQUFDLEdBQ2pCLENBQUMsS0FBSyxJQUFJLEVBQUUsQ0FBQyxHQUNiLFVBQVUsR0FDVixlQUFlLEdBQ2YsZUFBZSxFQUNsQjtJQUNKLENBQUM7Q0FDRjtBQXpZRCw0QkF5WUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXR5cGVzKi9cbi8vIE5vdGU6IGRpc2FibGluZyBiYW4tdHlwZSBydWxlIHNvIHdlIGRvbid0IGdldCBhbiBlcnJvciByZWZlcmVuY2luZyB0aGUgY2xhc3MgRnVuY3Rpb25cblxuaW1wb3J0IHBhdGggZnJvbSBcInBhdGhcIjtcbmltcG9ydCAqIGFzIGVzYnVpbGQgZnJvbSBcImVzYnVpbGRcIjtcbmltcG9ydCAqIGFzIGZzIGZyb20gXCJmcy1leHRyYVwiO1xuaW1wb3J0ICogYXMgY2RrIGZyb20gXCJAYXdzLWNkay9jb3JlXCI7XG5pbXBvcnQgKiBhcyBpYW0gZnJvbSBcIkBhd3MtY2RrL2F3cy1pYW1cIjtcbmltcG9ydCAqIGFzIGxhbWJkYSBmcm9tIFwiQGF3cy1jZGsvYXdzLWxhbWJkYVwiO1xuaW1wb3J0ICogYXMgbGFtYmRhTm9kZSBmcm9tIFwiQGF3cy1jZGsvYXdzLWxhbWJkYS1ub2RlanNcIjtcbmltcG9ydCAqIGFzIHNzbSBmcm9tIFwiQGF3cy1jZGsvYXdzLXNzbVwiO1xuXG5pbXBvcnQgeyBBcHAgfSBmcm9tIFwiLi9BcHBcIjtcbmltcG9ydCB7IFN0YWNrIH0gZnJvbSBcIi4vU3RhY2tcIjtcbmltcG9ydCB7IGJ1aWxkZXIgYXMgZ29CdWlsZGVyIH0gZnJvbSBcIi4vdXRpbC9nb0J1aWxkZXJcIjtcbmltcG9ydCB7IGJ1aWxkZXIgYXMgbm9kZUJ1aWxkZXIgfSBmcm9tIFwiLi91dGlsL25vZGVCdWlsZGVyXCI7XG5pbXBvcnQgeyBidWlsZGVyIGFzIGRvdG5ldEJ1aWxkZXIgfSBmcm9tIFwiLi91dGlsL2RvdG5ldEJ1aWxkZXJcIjtcbmltcG9ydCB7IGJ1aWxkZXIgYXMgcHl0aG9uQnVpbGRlciB9IGZyb20gXCIuL3V0aWwvcHl0aG9uQnVpbGRlclwiO1xuaW1wb3J0IHtcbiAgUGVybWlzc2lvblR5cGUsXG4gIFBlcm1pc3Npb25zLFxuICBhdHRhY2hQZXJtaXNzaW9uc1RvUm9sZSxcbn0gZnJvbSBcIi4vdXRpbC9wZXJtaXNzaW9uXCI7XG5cbmNvbnN0IHN1cHBvcnRlZFJ1bnRpbWVzID0gW1xuICBsYW1iZGEuUnVudGltZS5OT0RFSlMsXG4gIGxhbWJkYS5SdW50aW1lLk5PREVKU180XzMsXG4gIGxhbWJkYS5SdW50aW1lLk5PREVKU182XzEwLFxuICBsYW1iZGEuUnVudGltZS5OT0RFSlNfOF8xMCxcbiAgbGFtYmRhLlJ1bnRpbWUuTk9ERUpTXzEwX1gsXG4gIGxhbWJkYS5SdW50aW1lLk5PREVKU18xMl9YLFxuICBsYW1iZGEuUnVudGltZS5OT0RFSlNfMTRfWCxcbiAgbGFtYmRhLlJ1bnRpbWUuUFlUSE9OXzJfNyxcbiAgbGFtYmRhLlJ1bnRpbWUuUFlUSE9OXzNfNixcbiAgbGFtYmRhLlJ1bnRpbWUuUFlUSE9OXzNfNyxcbiAgbGFtYmRhLlJ1bnRpbWUuUFlUSE9OXzNfOCxcbiAgbGFtYmRhLlJ1bnRpbWUuRE9UTkVUX0NPUkVfMSxcbiAgbGFtYmRhLlJ1bnRpbWUuRE9UTkVUX0NPUkVfMixcbiAgbGFtYmRhLlJ1bnRpbWUuRE9UTkVUX0NPUkVfMl8xLFxuICBsYW1iZGEuUnVudGltZS5ET1RORVRfQ09SRV8zXzEsXG4gIGxhbWJkYS5SdW50aW1lLkdPXzFfWCxcbl07XG5cbmV4cG9ydCB0eXBlIEhhbmRsZXJQcm9wcyA9IEZ1bmN0aW9uSGFuZGxlclByb3BzO1xuZXhwb3J0IHR5cGUgRnVuY3Rpb25EZWZpbml0aW9uID0gc3RyaW5nIHwgRnVuY3Rpb24gfCBGdW5jdGlvblByb3BzO1xuXG5leHBvcnQgaW50ZXJmYWNlIEZ1bmN0aW9uUHJvcHNcbiAgZXh0ZW5kcyBPbWl0PGxhbWJkYS5GdW5jdGlvbk9wdGlvbnMsIFwidGltZW91dFwiIHwgXCJydW50aW1lXCI+IHtcbiAgLyoqXG4gICAqIFBhdGggdG8gdGhlIGVudHJ5IHBvaW50IGFuZCBoYW5kbGVyIGZ1bmN0aW9uLiBPZiB0aGUgZm9ybWF0OlxuICAgKiBgL3BhdGgvdG8vZmlsZS5mdW5jdGlvbmAuXG4gICAqL1xuICBoYW5kbGVyPzogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIHNvdXJjZSBkaXJlY3Rvcnkgd2hlcmUgdGhlIGVudHJ5IHBvaW50IGlzIGxvY2F0ZWQuIFRoZSBub2RlX21vZHVsZXMgaW4gdGhpc1xuICAgKiBkaXJlY3RvcnkgaXMgdXNlZCB0byBnZW5lcmF0ZSB0aGUgYnVuZGxlLlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIERlZmF1bHRzIHRvIHRoZSBhcHAgZGlyZWN0b3J5LlxuICAgKi9cbiAgc3JjUGF0aD86IHN0cmluZztcbiAgLyoqXG4gICAqIFRoZSBydW50aW1lIGVudmlyb25tZW50LlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIERlZmF1bHRzIHRvIE5PREVKU18xMl9YXG4gICAqL1xuICBydW50aW1lPzpcbiAgICB8IFwibm9kZWpzXCJcbiAgICB8IFwibm9kZWpzNC4zXCJcbiAgICB8IFwibm9kZWpzNi4xMFwiXG4gICAgfCBcIm5vZGVqczguMTBcIlxuICAgIHwgXCJub2RlanMxMC54XCJcbiAgICB8IFwibm9kZWpzMTIueFwiXG4gICAgfCBcIm5vZGVqczE0LnhcIlxuICAgIHwgXCJweXRob24yLjdcIlxuICAgIHwgXCJweXRob24zLjZcIlxuICAgIHwgXCJweXRob24zLjdcIlxuICAgIHwgXCJweXRob24zLjhcIlxuICAgIHwgXCJkb3RuZXRjb3JlMS4wXCJcbiAgICB8IFwiZG90bmV0Y29yZTIuMFwiXG4gICAgfCBcImRvdG5ldGNvcmUyLjFcIlxuICAgIHwgXCJkb3RuZXRjb3JlMy4xXCJcbiAgICB8IFwiZ28xLnhcIlxuICAgIHwgbGFtYmRhLlJ1bnRpbWU7XG4gIC8qKlxuICAgKiBUaGUgYW1vdW50IG9mIG1lbW9yeSBpbiBNQiBhbGxvY2F0ZWQuXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gRGVmYXVsdHMgdG8gMTAyNFxuICAgKi9cbiAgbWVtb3J5U2l6ZT86IG51bWJlcjtcbiAgLyoqXG4gICAqIFRoZSBleGVjdXRpb24gdGltZW91dCBpbiBzZWNvbmRzLlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIG51bWJlclxuICAgKi9cbiAgdGltZW91dD86IG51bWJlciB8IGNkay5EdXJhdGlvbjtcbiAgLyoqXG4gICAqIEVuYWJsZSBBV1MgWC1SYXkgVHJhY2luZy5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBEZWZhdWx0cyB0byBBQ1RJVkVcbiAgICovXG5cbiAgLyoqXG4gICAqIEVuYWJsZSBsb2NhbCBkZXZlbG9wbWVudFxuICAgKlxuICAgKiBAZGVmYXVsdCAtIERlZmF1bHRzIHRvIHRydWVcbiAgICovXG4gIGVuYWJsZUxpdmVEZXY/OiBib29sZWFuO1xuXG4gIHRyYWNpbmc/OiBsYW1iZGEuVHJhY2luZztcbiAgLyoqXG4gICAqIERpc2FibGUgYnVuZGxpbmcgd2l0aCBlc2J1aWxkLlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIERlZmF1bHRzIHRvIHRydWVcbiAgICovXG4gIGJ1bmRsZT86IEZ1bmN0aW9uQnVuZGxlUHJvcDtcbiAgcGVybWlzc2lvbnM/OiBQZXJtaXNzaW9ucztcbiAgbGF5ZXJzPzogbGFtYmRhLklMYXllclZlcnNpb25bXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBGdW5jdGlvbkhhbmRsZXJQcm9wcyB7XG4gIHNyY1BhdGg6IHN0cmluZztcbiAgaGFuZGxlcjogc3RyaW5nO1xuICBidW5kbGU6IEZ1bmN0aW9uQnVuZGxlUHJvcDtcbiAgcnVudGltZTogc3RyaW5nO1xufVxuXG5leHBvcnQgdHlwZSBGdW5jdGlvbkJ1bmRsZVByb3AgPSBGdW5jdGlvbkJ1bmRsZU9iamVjdCB8IGJvb2xlYW47XG5cbmV4cG9ydCB0eXBlIEZ1bmN0aW9uQnVuZGxlT2JqZWN0ID0gRnVuY3Rpb25CdW5kbGVCYXNlICZcbiAgKEZ1bmN0aW9uQnVuZGxlTm9kZWpzUHJvcHMgfCBGdW5jdGlvbkJ1bmRsZVB5dGhvblByb3BzKTtcblxuZXhwb3J0IHR5cGUgRnVuY3Rpb25CdW5kbGVCYXNlID0ge1xuICByZWFkb25seSBjb3B5RmlsZXM/OiBGdW5jdGlvbkJ1bmRsZUNvcHlGaWxlc1Byb3BzW107XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIEZ1bmN0aW9uQnVuZGxlTm9kZWpzUHJvcHMge1xuICBsb2FkZXI/OiB7IFtleHQ6IHN0cmluZ106IGVzYnVpbGQuTG9hZGVyIH07XG4gIGV4dGVybmFsTW9kdWxlcz86IHN0cmluZ1tdO1xuICBub2RlTW9kdWxlcz86IHN0cmluZ1tdO1xuICBjb21tYW5kSG9va3M/OiBsYW1iZGFOb2RlLklDb21tYW5kSG9va3M7XG4gIGVzYnVpbGRDb25maWc/OiBzdHJpbmcgfCBGdW5jdGlvbkJ1bmRsZUVzYnVpbGRDb25maWc7XG4gIG1pbmlmeT86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRnVuY3Rpb25CdW5kbGVQeXRob25Qcm9wcyB7XG4gIGluc3RhbGxDb21tYW5kcz86IHN0cmluZ1tdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZ1bmN0aW9uQnVuZGxlQ29weUZpbGVzUHJvcHMge1xuICBmcm9tOiBzdHJpbmc7XG4gIHRvPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZ1bmN0aW9uQnVuZGxlRXNidWlsZENvbmZpZyB7XG4gIGRlZmluZT86IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH07XG4gIGtlZXBOYW1lcz86IGJvb2xlYW47XG4gIHBsdWdpbnM/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBjbGFzcyBGdW5jdGlvbiBleHRlbmRzIGxhbWJkYS5GdW5jdGlvbiB7XG4gIHB1YmxpYyByZWFkb25seSBfaXNMaXZlRGV2RW5hYmxlZDogYm9vbGVhbjtcblxuICBjb25zdHJ1Y3RvcihzY29wZTogY2RrLkNvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM6IEZ1bmN0aW9uUHJvcHMpIHtcbiAgICBjb25zdCByb290ID0gc2NvcGUubm9kZS5yb290IGFzIEFwcDtcbiAgICBjb25zdCBzdGFjayA9IFN0YWNrLm9mKHNjb3BlKSBhcyBTdGFjaztcblxuICAgIC8vIE1lcmdlIHdpdGggYXBwIGRlZmF1bHRGdW5jdGlvblByb3BzXG4gICAgLy8gbm90ZTogcmV2ZXJzZSBvcmRlciBzbyBsYXRlciBwcm9wIG92ZXJyaWRlIGVhcmxpZXIgb25lc1xuICAgIHN0YWNrLmRlZmF1bHRGdW5jdGlvblByb3BzXG4gICAgICAuc2xpY2UoKVxuICAgICAgLnJldmVyc2UoKVxuICAgICAgLmZvckVhY2goKHBlcikgPT4ge1xuICAgICAgICBwcm9wcyA9IEZ1bmN0aW9uLm1lcmdlUHJvcHMocGVyLCBwcm9wcyk7XG4gICAgICB9KTtcblxuICAgIC8vIFNldCBkZWZhdWx0c1xuICAgIGNvbnN0IGhhbmRsZXIgPSBwcm9wcy5oYW5kbGVyO1xuICAgIGxldCB0aW1lb3V0ID0gcHJvcHMudGltZW91dCB8fCAxMDtcbiAgICBjb25zdCBzcmNQYXRoID0gRnVuY3Rpb24ubm9ybWFsaXplU3JjUGF0aChwcm9wcy5zcmNQYXRoIHx8IFwiLlwiKTtcbiAgICBjb25zdCBtZW1vcnlTaXplID0gcHJvcHMubWVtb3J5U2l6ZSB8fCAxMDI0O1xuICAgIGNvbnN0IHRyYWNpbmcgPSBwcm9wcy50cmFjaW5nIHx8IGxhbWJkYS5UcmFjaW5nLkFDVElWRTtcbiAgICBsZXQgcnVudGltZSA9IHByb3BzLnJ1bnRpbWUgfHwgbGFtYmRhLlJ1bnRpbWUuTk9ERUpTXzEyX1g7XG4gICAgbGV0IGJ1bmRsZSA9IHByb3BzLmJ1bmRsZTtcbiAgICBjb25zdCBwZXJtaXNzaW9ucyA9IHByb3BzLnBlcm1pc3Npb25zO1xuICAgIGNvbnN0IGlzTGl2ZURldkVuYWJsZWQgPSBwcm9wcy5lbmFibGVMaXZlRGV2ID09PSBmYWxzZSA/IGZhbHNlIDogdHJ1ZTtcblxuICAgIC8vIFZhbGlkYXRlIGhhbmRsZXJcbiAgICBpZiAoIWhhbmRsZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gaGFuZGxlciBkZWZpbmVkIGZvciB0aGUgXCIke2lkfVwiIExhbWJkYSBmdW5jdGlvbmApO1xuICAgIH1cblxuICAgIC8vIE5vcm1hbGl6ZSBydW50aW1lXG4gICAgY29uc3QgcnVudGltZVN0ciA9XG4gICAgICB0eXBlb2YgcnVudGltZSA9PT0gXCJzdHJpbmdcIiA/IHJ1bnRpbWUgOiBydW50aW1lLnRvU3RyaW5nKCk7XG4gICAgY29uc3QgcnVudGltZUNsYXNzID0gc3VwcG9ydGVkUnVudGltZXMuZmluZChcbiAgICAgIChwZXIpID0+IHBlci50b1N0cmluZygpID09PSBydW50aW1lU3RyXG4gICAgKTtcbiAgICBpZiAoIXJ1bnRpbWVDbGFzcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgVGhlIHNwZWNpZmllZCBydW50aW1lIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIHNzdC5GdW5jdGlvbi4gT25seSBOb2RlSlMsIFB5dGhvbiwgR28sIGFuZCAuTkVUIHJ1bnRpbWVzIGFyZSBjdXJyZW50bHkgc3VwcG9ydGVkLmBcbiAgICAgICk7XG4gICAgfVxuICAgIHJ1bnRpbWUgPSBydW50aW1lQ2xhc3M7XG5cbiAgICAvLyBOb3JtYWxpemUgdGltZW91dFxuICAgIGlmICh0eXBlb2YgdGltZW91dCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgdGltZW91dCA9IGNkay5EdXJhdGlvbi5zZWNvbmRzKHRpbWVvdXQpO1xuICAgIH1cblxuICAgIC8vIFZhbGlkYXRlIGlucHV0XG4gICAgY29uc3QgaXNOb2RlUnVudGltZSA9IHJ1bnRpbWVTdHIuc3RhcnRzV2l0aChcIm5vZGVqc1wiKTtcbiAgICBjb25zdCBpc0dvUnVudGltZSA9IHJ1bnRpbWVTdHIuc3RhcnRzV2l0aChcImdvXCIpO1xuICAgIGNvbnN0IGlzUHl0aG9uUnVudGltZSA9IHJ1bnRpbWVTdHIuc3RhcnRzV2l0aChcInB5dGhvblwiKTtcbiAgICBjb25zdCBpc0RvdG5ldFJ1bnRpbWUgPSBydW50aW1lU3RyLnN0YXJ0c1dpdGgoXCJkb3RuZXRjb3JlXCIpO1xuICAgIGlmIChpc05vZGVSdW50aW1lKSB7XG4gICAgICBidW5kbGUgPSBidW5kbGUgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBwcm9wcy5idW5kbGU7XG4gICAgICBpZiAoIWJ1bmRsZSAmJiBzcmNQYXRoID09PSBcIi5cIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYEJ1bmRsZSBjYW5ub3QgYmUgZGlzYWJsZWQgZm9yIHRoZSBcIiR7aWR9XCIgZnVuY3Rpb24gc2luY2UgdGhlIFwic3JjUGF0aFwiIGlzIHNldCB0byB0aGUgcHJvamVjdCByb290LiBSZWFkIG1vcmUgaGVyZSDigJQgaHR0cHM6Ly9naXRodWIuY29tL3NlcnZlcmxlc3Mtc3RhY2svc2VydmVybGVzcy1zdGFjay9pc3N1ZXMvNzhgXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1B5dGhvblJ1bnRpbWUpIHtcbiAgICAgIGJ1bmRsZSA9IGJ1bmRsZSA9PT0gdW5kZWZpbmVkID8ge30gOiBwcm9wcy5idW5kbGU7XG4gICAgICBpZiAoc3JjUGF0aCA9PT0gXCIuXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBDYW5ub3Qgc2V0IHRoZSBcInNyY1BhdGhcIiB0byB0aGUgcHJvamVjdCByb290IGZvciB0aGUgXCIke2lkfVwiIGZ1bmN0aW9uLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgbG9jYWwgZGV2ZWxvcG1lbnQgKGllLiBzc3Qgc3RhcnQpXG4gICAgLy8gLSBzZXQgcnVudGltZSB0byBub2RlanMxMi54IGZvciBub24tTm9kZSBydW50aW1lcyAoYi9jIHRoZSBzdHViIGlzIGluIE5vZGUpXG4gICAgLy8gLSBzZXQgcmV0cnkgdG8gMC4gV2hlbiB0aGUgZGVidWdnZXIgaXMgZGlzY29ubmVjdGVkLCB0aGUgQ3JvbiBjb25zdHJ1Y3RcbiAgICAvLyAgIHdpbGwgc3RpbGwgdHJ5IHRvIHBlcmlvZGljYWxseSBpbnZva2UgdGhlIExhbWJkYSwgYW5kIHRoZSByZXF1ZXN0cyB3b3VsZFxuICAgIC8vICAgZmFpbCBhbmQgcmV0cnkuIFNvIHdoZW4gbGF1bmNoaW5nIGBzc3Qgc3RhcnRgLCBhIGNvdXBsZSBvZiByZXRyeSByZXF1ZXN0c1xuICAgIC8vICAgZnJvbSByZWNlbnQgZmFpbGVkIHJlcXVlc3Qgd2lsbCBiZSByZWNlaXZlZC4gQW5kIHRoaXMgYmVoYXZpb3IgaXMgY29uZnVzaW5nLlxuICAgIGlmIChcbiAgICAgIGlzTGl2ZURldkVuYWJsZWQgJiZcbiAgICAgIHJvb3QubG9jYWwgJiZcbiAgICAgIHJvb3QuZGVidWdFbmRwb2ludCAmJlxuICAgICAgcm9vdC5kZWJ1Z0J1Y2tldE5hbWUgJiZcbiAgICAgIHJvb3QuZGVidWdCdWNrZXRBcm5cbiAgICApIHtcbiAgICAgIC8vIElmIGRlYnVnSW5jcmVhc2VUaW1lb3V0IGlzIGVuYWJsZWQ6XG4gICAgICAvLyAgIHNldCB0aW1lb3V0IHRvIDkwMC4gVGhpcyB3aWxsIGdpdmUgcGVvcGxlIG1vcmUgdGltZSB0byBkZWJ1ZyB0aGUgZnVuY3Rpb25cbiAgICAgIC8vICAgd2l0aG91dCB0aW1pbmcgb3V0IHRoZSByZXF1ZXN0LiBOb3RlIEFQSSBHYXRld2F5IHJlcXVlc3RzIGhhdmUgYSBtYXhpbXVtXG4gICAgICAvLyAgIHRpbWVvdXQgb2YgMjlzLiBJbiB0aGlzIGNhc2UsIHRoZSBBUEkgd2lsbCB0aW1lb3V0LCBidXQgdGhlIExhbWJkYSBmdW5jdGlvblxuICAgICAgLy8gICB3aWxsIGNvbnRpbnVlIHRvIHJ1bi5cbiAgICAgIGxldCBkZWJ1Z092ZXJyaWRlUHJvcHM7XG4gICAgICBpZiAocm9vdC5kZWJ1Z0luY3JlYXNlVGltZW91dCkge1xuICAgICAgICBkZWJ1Z092ZXJyaWRlUHJvcHMgPSB7XG4gICAgICAgICAgdGltZW91dDogY2RrLkR1cmF0aW9uLnNlY29uZHMoOTAwKSxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChyb290LmRlYnVnQnJpZGdlKSB7XG4gICAgICAgIHN1cGVyKHNjb3BlLCBpZCwge1xuICAgICAgICAgIC4uLnByb3BzLFxuICAgICAgICAgIHJ1bnRpbWU6IGxhbWJkYS5SdW50aW1lLkdPXzFfWCxcbiAgICAgICAgICB0cmFjaW5nLFxuICAgICAgICAgIHRpbWVvdXQsXG4gICAgICAgICAgbWVtb3J5U2l6ZSxcbiAgICAgICAgICBoYW5kbGVyOiBcImhhbmRsZXJcIixcbiAgICAgICAgICBjb2RlOiBsYW1iZGEuQ29kZS5mcm9tQXNzZXQoXG4gICAgICAgICAgICBwYXRoLnJlc29sdmUoX19kaXJuYW1lLCBcIi4uL2Rpc3QvYnJpZGdlX2NsaWVudC9cIilcbiAgICAgICAgICApLFxuICAgICAgICAgIGVudmlyb25tZW50OiB7XG4gICAgICAgICAgICAuLi4ocHJvcHMuZW52aXJvbm1lbnQgfHwge30pLFxuICAgICAgICAgICAgU1NUX0RFQlVHX0JSSURHRTogcm9vdC5kZWJ1Z0JyaWRnZSxcbiAgICAgICAgICAgIFNTVF9ERUJVR19TUkNfUEFUSDogc3JjUGF0aCxcbiAgICAgICAgICAgIFNTVF9ERUJVR19TUkNfSEFORExFUjogaGFuZGxlcixcbiAgICAgICAgICAgIFNTVF9ERUJVR19FTkRQT0lOVDogcm9vdC5kZWJ1Z0VuZHBvaW50LFxuICAgICAgICAgIH0sXG4gICAgICAgICAgbGF5ZXJzOiBGdW5jdGlvbi5oYW5kbGVJbXBvcnRlZExheWVycyhzY29wZSwgcHJvcHMubGF5ZXJzIHx8IFtdKSxcbiAgICAgICAgICAuLi4oZGVidWdPdmVycmlkZVByb3BzIHx8IHt9KSxcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdXBlcihzY29wZSwgaWQsIHtcbiAgICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgICBydW50aW1lOiBpc05vZGVSdW50aW1lID8gcnVudGltZSA6IGxhbWJkYS5SdW50aW1lLk5PREVKU18xMl9YLFxuICAgICAgICAgIHRyYWNpbmcsXG4gICAgICAgICAgdGltZW91dCxcbiAgICAgICAgICBtZW1vcnlTaXplLFxuICAgICAgICAgIGhhbmRsZXI6IFwiaW5kZXgubWFpblwiLFxuICAgICAgICAgIHJldHJ5QXR0ZW1wdHM6IDAsXG4gICAgICAgICAgY29kZTogbGFtYmRhLkNvZGUuZnJvbUFzc2V0KFxuICAgICAgICAgICAgcGF0aC5yZXNvbHZlKF9fZGlybmFtZSwgXCIuLi9kaXN0L3N0dWIuemlwXCIpXG4gICAgICAgICAgKSxcbiAgICAgICAgICBlbnZpcm9ubWVudDoge1xuICAgICAgICAgICAgLi4uKHByb3BzLmVudmlyb25tZW50IHx8IHt9KSxcbiAgICAgICAgICAgIFNTVF9ERUJVR19TUkNfUEFUSDogc3JjUGF0aCxcbiAgICAgICAgICAgIFNTVF9ERUJVR19TUkNfSEFORExFUjogaGFuZGxlcixcbiAgICAgICAgICAgIFNTVF9ERUJVR19FTkRQT0lOVDogcm9vdC5kZWJ1Z0VuZHBvaW50LFxuICAgICAgICAgICAgU1NUX0RFQlVHX0JVQ0tFVF9OQU1FOiByb290LmRlYnVnQnVja2V0TmFtZSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGxheWVyczogRnVuY3Rpb24uaGFuZGxlSW1wb3J0ZWRMYXllcnMoc2NvcGUsIHByb3BzLmxheWVycyB8fCBbXSksXG4gICAgICAgICAgLi4uKGRlYnVnT3ZlcnJpZGVQcm9wcyB8fCB7fSksXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5hdHRhY2hQZXJtaXNzaW9ucyhbXG4gICAgICAgIG5ldyBpYW0uUG9saWN5U3RhdGVtZW50KHtcbiAgICAgICAgICBhY3Rpb25zOiBbXCJzMzoqXCJdLFxuICAgICAgICAgIGVmZmVjdDogaWFtLkVmZmVjdC5BTExPVyxcbiAgICAgICAgICByZXNvdXJjZXM6IFtyb290LmRlYnVnQnVja2V0QXJuLCBgJHtyb290LmRlYnVnQnVja2V0QXJufS8qYF0sXG4gICAgICAgIH0pLFxuICAgICAgXSk7XG4gICAgfVxuICAgIC8vIEhhbmRsZSByZW1vdmUgKGllLiBzc3QgcmVtb3ZlKVxuICAgIGVsc2UgaWYgKHJvb3Quc2tpcEJ1aWxkKSB7XG4gICAgICAvLyBOb3RlOiBuZWVkIHRvIG92ZXJyaWRlIHJ1bnRpbWUgYXMgQ0RLIGRvZXMgbm90IHN1cHBvcnQgaW5saW5lIGNvZGVcbiAgICAgIC8vICAgICAgIGZvciBzb21lIHJ1bnRpbWVzLlxuICAgICAgc3VwZXIoc2NvcGUsIGlkLCB7XG4gICAgICAgIC4uLnByb3BzLFxuICAgICAgICBydW50aW1lOiBsYW1iZGEuUnVudGltZS5OT0RFSlNfMTJfWCxcbiAgICAgICAgaGFuZGxlcjogXCJwbGFjZWhvbGRlclwiLFxuICAgICAgICBjb2RlOiBsYW1iZGEuQ29kZS5mcm9tQXNzZXQoXG4gICAgICAgICAgcGF0aC5yZXNvbHZlKF9fZGlybmFtZSwgXCIuLi9hc3NldHMvRnVuY3Rpb24vcGxhY2Vob2xkZXItc3R1YlwiKVxuICAgICAgICApLFxuICAgICAgICB0aW1lb3V0LFxuICAgICAgICBsYXllcnM6IEZ1bmN0aW9uLmhhbmRsZUltcG9ydGVkTGF5ZXJzKHNjb3BlLCBwcm9wcy5sYXllcnMgfHwgW10pLFxuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIEhhbmRsZSBidWlsZFxuICAgIGVsc2Uge1xuICAgICAgbGV0IG91dENvZGU6IGxhbWJkYS5Bc3NldENvZGUsIG91dEhhbmRsZXI7XG4gICAgICBpZiAoaXNEb3RuZXRSdW50aW1lKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGRvdG5ldEJ1aWxkZXIoe1xuICAgICAgICAgIHNyY1BhdGgsXG4gICAgICAgICAgaGFuZGxlcixcbiAgICAgICAgICBidWlsZERpcjogcm9vdC5idWlsZERpcixcbiAgICAgICAgICBzdGFjazogU3RhY2sub2Yoc2NvcGUpLnN0YWNrTmFtZSxcbiAgICAgICAgfSk7XG4gICAgICAgIG91dENvZGUgPSByZXQub3V0Q29kZTtcbiAgICAgICAgb3V0SGFuZGxlciA9IHJldC5vdXRIYW5kbGVyO1xuICAgICAgfSBlbHNlIGlmIChpc0dvUnVudGltZSkge1xuICAgICAgICBjb25zdCByZXQgPSBnb0J1aWxkZXIoe1xuICAgICAgICAgIHNyY1BhdGgsXG4gICAgICAgICAgaGFuZGxlcixcbiAgICAgICAgICBidWlsZERpcjogcm9vdC5idWlsZERpcixcbiAgICAgICAgfSk7XG4gICAgICAgIG91dENvZGUgPSByZXQub3V0Q29kZTtcbiAgICAgICAgb3V0SGFuZGxlciA9IHJldC5vdXRIYW5kbGVyO1xuICAgICAgfSBlbHNlIGlmIChpc1B5dGhvblJ1bnRpbWUpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gcHl0aG9uQnVpbGRlcih7XG4gICAgICAgICAgYnVuZGxlOiBidW5kbGUgYXMgRnVuY3Rpb25CdW5kbGVQeXRob25Qcm9wcyxcbiAgICAgICAgICBzcmNQYXRoLFxuICAgICAgICAgIGhhbmRsZXIsXG4gICAgICAgICAgcnVudGltZSxcbiAgICAgICAgICBzdGFjazogU3RhY2sub2Yoc2NvcGUpLnN0YWNrTmFtZSxcbiAgICAgICAgfSk7XG4gICAgICAgIG91dENvZGUgPSByZXQub3V0Q29kZTtcbiAgICAgICAgb3V0SGFuZGxlciA9IHJldC5vdXRIYW5kbGVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcmV0ID0gbm9kZUJ1aWxkZXIoe1xuICAgICAgICAgIGJ1bmRsZTogYnVuZGxlIGFzIGJvb2xlYW4gfCBGdW5jdGlvbkJ1bmRsZU5vZGVqc1Byb3BzLFxuICAgICAgICAgIHNyY1BhdGgsXG4gICAgICAgICAgaGFuZGxlcixcbiAgICAgICAgICBydW50aW1lLFxuICAgICAgICAgIGJ1aWxkRGlyOiByb290LmJ1aWxkRGlyLFxuICAgICAgICAgIGVzYnVpbGRDb25maWc6IHJvb3QuZXNidWlsZENvbmZpZyxcbiAgICAgICAgfSk7XG4gICAgICAgIG91dENvZGUgPSByZXQub3V0Q29kZTtcbiAgICAgICAgb3V0SGFuZGxlciA9IHJldC5vdXRIYW5kbGVyO1xuICAgICAgfVxuICAgICAgRnVuY3Rpb24uY29weUZpbGVzKGJ1bmRsZSwgc3JjUGF0aCwgb3V0Q29kZS5wYXRoKTtcbiAgICAgIHN1cGVyKHNjb3BlLCBpZCwge1xuICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgcnVudGltZSxcbiAgICAgICAgdHJhY2luZyxcbiAgICAgICAgbWVtb3J5U2l6ZSxcbiAgICAgICAgaGFuZGxlcjogb3V0SGFuZGxlcixcbiAgICAgICAgY29kZTogb3V0Q29kZSxcbiAgICAgICAgdGltZW91dCxcbiAgICAgICAgbGF5ZXJzOiBGdW5jdGlvbi5oYW5kbGVJbXBvcnRlZExheWVycyhzY29wZSwgcHJvcHMubGF5ZXJzIHx8IFtdKSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEVuYWJsZSByZXVzaW5nIGNvbm5lY3Rpb25zIHdpdGggS2VlcC1BbGl2ZSBmb3IgTm9kZUpzIExhbWJkYSBmdW5jdGlvblxuICAgIGlmIChpc05vZGVSdW50aW1lKSB7XG4gICAgICB0aGlzLmFkZEVudmlyb25tZW50KFwiQVdTX05PREVKU19DT05ORUNUSU9OX1JFVVNFX0VOQUJMRURcIiwgXCIxXCIsIHtcbiAgICAgICAgcmVtb3ZlSW5FZGdlOiB0cnVlLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gQXR0YWNoIHBlcm1pc3Npb25zXG4gICAgaWYgKHBlcm1pc3Npb25zKSB7XG4gICAgICB0aGlzLmF0dGFjaFBlcm1pc3Npb25zKHBlcm1pc3Npb25zKTtcbiAgICB9XG5cbiAgICAvLyByZWdpc3RlciBMYW1iZGEgZnVuY3Rpb24gaW4gYXBwXG4gICAgcm9vdC5yZWdpc3RlckxhbWJkYUhhbmRsZXIoe1xuICAgICAgc3JjUGF0aCxcbiAgICAgIGhhbmRsZXIsXG4gICAgICBidW5kbGUsXG4gICAgICBydW50aW1lOiBydW50aW1lU3RyLFxuICAgIH0gYXMgRnVuY3Rpb25IYW5kbGVyUHJvcHMpO1xuXG4gICAgdGhpcy5faXNMaXZlRGV2RW5hYmxlZCA9IGlzTGl2ZURldkVuYWJsZWQ7XG4gIH1cblxuICBwdWJsaWMgYXR0YWNoUGVybWlzc2lvbnMocGVybWlzc2lvbnM6IFBlcm1pc3Npb25zKTogdm9pZCB7XG4gICAgaWYgKHRoaXMucm9sZSkge1xuICAgICAgYXR0YWNoUGVybWlzc2lvbnNUb1JvbGUodGhpcy5yb2xlIGFzIGlhbS5Sb2xlLCBwZXJtaXNzaW9ucyk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIG5vcm1hbGl6ZVNyY1BhdGgoc3JjUGF0aDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gc3JjUGF0aC5yZXBsYWNlKC9cXC8rJC8sIFwiXCIpO1xuICB9XG5cbiAgc3RhdGljIGNvcHlGaWxlcyhcbiAgICBidW5kbGU6IEZ1bmN0aW9uQnVuZGxlUHJvcCB8IHVuZGVmaW5lZCxcbiAgICBzcmNQYXRoOiBzdHJpbmcsXG4gICAgYnVpbGRQYXRoOiBzdHJpbmdcbiAgKSB7XG4gICAgaWYgKCFidW5kbGUpIHJldHVybjtcbiAgICBpZiAodHlwZW9mIGJ1bmRsZSA9PT0gXCJib29sZWFuXCIpIHJldHVybjtcbiAgICBpZiAoIWJ1bmRsZS5jb3B5RmlsZXMpIHJldHVybjtcblxuICAgIGJ1bmRsZS5jb3B5RmlsZXMuZm9yRWFjaCgoZW50cnkpID0+IHtcbiAgICAgIGNvbnN0IGZyb21QYXRoID0gcGF0aC5qb2luKHNyY1BhdGgsIGVudHJ5LmZyb20pO1xuICAgICAgaWYgKCFmcy5leGlzdHNTeW5jKGZyb21QYXRoKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBUcmllZCB0byBjb3B5IG5vbmV4aXN0ZW50IGZpbGUgZnJvbSBcIiR7cGF0aC5yZXNvbHZlKFxuICAgICAgICAgICAgZnJvbVBhdGhcbiAgICAgICAgICApfVwiIC0gY2hlY2sgY29weUZpbGVzIGVudHJ5IFwiJHtlbnRyeS5mcm9tfVwiYFxuICAgICAgICApO1xuICAgICAgY29uc3QgdG8gPSBlbnRyeS50byB8fCBlbnRyeS5mcm9tO1xuICAgICAgaWYgKHBhdGguaXNBYnNvbHV0ZSh0bykpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29weSBkZXN0aW5hdGlvbiBwYXRoIFwiJHt0b31cIiBtdXN0IGJlIHJlbGF0aXZlYCk7XG4gICAgICBjb25zdCB0b1BhdGggPSBwYXRoLmpvaW4oYnVpbGRQYXRoLCB0byk7XG4gICAgICBmcy5jb3B5U3luYyhmcm9tUGF0aCwgdG9QYXRoKTtcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRpYyBoYW5kbGVJbXBvcnRlZExheWVycyhcbiAgICBzY29wZTogY2RrLkNvbnN0cnVjdCxcbiAgICBsYXllcnM6IGxhbWJkYS5JTGF5ZXJWZXJzaW9uW11cbiAgKTogbGFtYmRhLklMYXllclZlcnNpb25bXSB7XG4gICAgcmV0dXJuIGxheWVycy5tYXAoKGxheWVyKSA9PiB7XG4gICAgICBjb25zdCBsYXllclN0YWNrID0gU3RhY2sub2YobGF5ZXIpO1xuICAgICAgY29uc3QgY3VycmVudFN0YWNrID0gU3RhY2sub2Yoc2NvcGUpO1xuICAgICAgLy8gVXNlIGxheWVyIGRpcmVjdGx5IGlmOlxuICAgICAgLy8gLSBsYXllciBpcyBjcmVhdGVkIGluIHRoZSBjdXJyZW50IHN0YWNrOyBPUlxuICAgICAgLy8gLSBsYXllciBpcyBpbXBvcnRlZCAoaWUuIGxheWVyQXJuIGlzIGEgc3RyaW5nKVxuICAgICAgaWYgKFxuICAgICAgICBsYXllclN0YWNrID09PSBjdXJyZW50U3RhY2sgfHxcbiAgICAgICAgIWNkay5Ub2tlbi5pc1VucmVzb2x2ZWQobGF5ZXIubGF5ZXJWZXJzaW9uQXJuKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBsYXllcjtcbiAgICAgIH1cbiAgICAgIC8vIGxheWVyIGlzIGNyZWF0ZWQgZnJvbSBhbm90aGVyIHN0YWNrXG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gc2V0IHN0YWNrIGRlcGVuZGVuY3kgYi9jIGxheWVyU3RhY2sgbmVlZCB0byBjcmVhdGUgdGhlIFNTTSBmaXJzdFxuICAgICAgICBjdXJyZW50U3RhY2suYWRkRGVwZW5kZW5jeShsYXllclN0YWNrKTtcbiAgICAgICAgLy8gc3RvcmUgbGF5ZXIgQVJOIGluIFNTTSBpbiBsYXllcidzIHN0YWNrXG4gICAgICAgIGNvbnN0IHBhcmFtZXRlcklkID0gYCR7bGF5ZXIubm9kZS5pZH1Bcm4tJHtsYXllci5ub2RlLmFkZHJ9YDtcbiAgICAgICAgY29uc3QgcGFyYW1ldGVyTmFtZSA9IGAvbGF5ZXJzLyR7bGF5ZXJTdGFjay5ub2RlLmlkfS8ke3BhcmFtZXRlcklkfWA7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nU3NtUGFyYW0gPSBsYXllclN0YWNrLm5vZGUudHJ5RmluZENoaWxkKHBhcmFtZXRlcklkKTtcbiAgICAgICAgaWYgKCFleGlzdGluZ1NzbVBhcmFtKSB7XG4gICAgICAgICAgbmV3IHNzbS5TdHJpbmdQYXJhbWV0ZXIobGF5ZXJTdGFjaywgcGFyYW1ldGVySWQsIHtcbiAgICAgICAgICAgIHBhcmFtZXRlck5hbWUsXG4gICAgICAgICAgICBzdHJpbmdWYWx1ZTogbGF5ZXIubGF5ZXJWZXJzaW9uQXJuLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGltcG9ydCBsYXllciBmcm9tIFNTTSB2YWx1ZVxuICAgICAgICBjb25zdCBsYXllcklkID0gYEkke2xheWVyLm5vZGUuaWR9LSR7bGF5ZXIubm9kZS5hZGRyfWA7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nTGF5ZXIgPSBzY29wZS5ub2RlLnRyeUZpbmRDaGlsZChsYXllcklkKTtcbiAgICAgICAgaWYgKGV4aXN0aW5nTGF5ZXIpIHtcbiAgICAgICAgICByZXR1cm4gZXhpc3RpbmdMYXllciBhcyBsYW1iZGEuTGF5ZXJWZXJzaW9uO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBsYW1iZGEuTGF5ZXJWZXJzaW9uLmZyb21MYXllclZlcnNpb25Bcm4oXG4gICAgICAgICAgICBzY29wZSxcbiAgICAgICAgICAgIGxheWVySWQsXG4gICAgICAgICAgICBzc20uU3RyaW5nUGFyYW1ldGVyLnZhbHVlRm9yU3RyaW5nUGFyYW1ldGVyKHNjb3BlLCBwYXJhbWV0ZXJOYW1lKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tRGVmaW5pdGlvbihcbiAgICBzY29wZTogY2RrLkNvbnN0cnVjdCxcbiAgICBpZDogc3RyaW5nLFxuICAgIGRlZmluaXRpb246IEZ1bmN0aW9uRGVmaW5pdGlvbixcbiAgICBpbmhlcml0ZWRQcm9wcz86IEZ1bmN0aW9uUHJvcHMsXG4gICAgaW5oZXJpdEVycm9yTWVzc2FnZT86IHN0cmluZ1xuICApOiBGdW5jdGlvbiB7XG4gICAgaWYgKHR5cGVvZiBkZWZpbml0aW9uID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKHNjb3BlLCBpZCwge1xuICAgICAgICAuLi4oaW5oZXJpdGVkUHJvcHMgfHwge30pLFxuICAgICAgICBoYW5kbGVyOiBkZWZpbml0aW9uLFxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChkZWZpbml0aW9uIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgIGlmIChpbmhlcml0ZWRQcm9wcyAmJiBPYmplY3Qua2V5cyhpbmhlcml0ZWRQcm9wcykubGVuZ3RoID4gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgaW5oZXJpdEVycm9yTWVzc2FnZSB8fFxuICAgICAgICAgICAgYENhbm5vdCBpbmhlcml0IGRlZmF1bHQgcHJvcHMgd2hlbiBhIEZ1bmN0aW9uIGlzIHByb3ZpZGVkYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlZmluaXRpb247XG4gICAgfSBlbHNlIGlmIChkZWZpbml0aW9uIGluc3RhbmNlb2YgbGFtYmRhLkZ1bmN0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBQbGVhc2UgdXNlIHNzdC5GdW5jdGlvbiBpbnN0ZWFkIG9mIGxhbWJkYS5GdW5jdGlvbiBmb3IgdGhlIFwiJHtpZH1cIiBGdW5jdGlvbi5gXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoKGRlZmluaXRpb24gYXMgRnVuY3Rpb25Qcm9wcykuaGFuZGxlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKFxuICAgICAgICBzY29wZSxcbiAgICAgICAgaWQsXG4gICAgICAgIEZ1bmN0aW9uLm1lcmdlUHJvcHMoaW5oZXJpdGVkUHJvcHMsIGRlZmluaXRpb24pXG4gICAgICApO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZnVuY3Rpb24gZGVmaW5pdGlvbiBmb3IgdGhlIFwiJHtpZH1cIiBGdW5jdGlvbmApO1xuICB9XG5cbiAgc3RhdGljIG1lcmdlUHJvcHMoXG4gICAgYmFzZVByb3BzPzogRnVuY3Rpb25Qcm9wcyxcbiAgICBwcm9wcz86IEZ1bmN0aW9uUHJvcHNcbiAgKTogRnVuY3Rpb25Qcm9wcyB7XG4gICAgLy8gTWVyZ2UgZW52aXJvbm1lbnRcbiAgICBjb25zdCBlbnZpcm9ubWVudCA9IHtcbiAgICAgIC4uLihiYXNlUHJvcHM/LmVudmlyb25tZW50IHx8IHt9KSxcbiAgICAgIC4uLihwcm9wcz8uZW52aXJvbm1lbnQgfHwge30pLFxuICAgIH07XG4gICAgY29uc3QgZW52aXJvbm1lbnRQcm9wID1cbiAgICAgIE9iamVjdC5rZXlzKGVudmlyb25tZW50KS5sZW5ndGggPT09IDAgPyB7fSA6IHsgZW52aXJvbm1lbnQgfTtcblxuICAgIC8vIE1lcmdlIGxheWVyc1xuICAgIGNvbnN0IGxheWVycyA9IFsuLi4oYmFzZVByb3BzPy5sYXllcnMgfHwgW10pLCAuLi4ocHJvcHM/LmxheWVycyB8fCBbXSldO1xuICAgIGNvbnN0IGxheWVyc1Byb3AgPSBsYXllcnMubGVuZ3RoID09PSAwID8ge30gOiB7IGxheWVycyB9O1xuXG4gICAgLy8gTWVyZ2UgcGVybWlzc2lvbnNcbiAgICBsZXQgcGVybWlzc2lvbnNQcm9wO1xuICAgIGlmIChcbiAgICAgIGJhc2VQcm9wcz8ucGVybWlzc2lvbnMgPT09IFBlcm1pc3Npb25UeXBlLkFMTCB8fFxuICAgICAgcHJvcHM/LnBlcm1pc3Npb25zID09PSBQZXJtaXNzaW9uVHlwZS5BTExcbiAgICApIHtcbiAgICAgIHBlcm1pc3Npb25zUHJvcCA9IHsgcGVybWlzc2lvbnM6IFBlcm1pc3Npb25UeXBlLkFMTCB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBwZXJtaXNzaW9ucyA9IChiYXNlUHJvcHM/LnBlcm1pc3Npb25zIHx8IFtdKS5jb25jYXQoXG4gICAgICAgIHByb3BzPy5wZXJtaXNzaW9ucyB8fCBbXVxuICAgICAgKTtcbiAgICAgIHBlcm1pc3Npb25zUHJvcCA9IHBlcm1pc3Npb25zLmxlbmd0aCA9PT0gMCA/IHt9IDogeyBwZXJtaXNzaW9ucyB9O1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAuLi4oYmFzZVByb3BzIHx8IHt9KSxcbiAgICAgIC4uLihwcm9wcyB8fCB7fSksXG4gICAgICAuLi5sYXllcnNQcm9wLFxuICAgICAgLi4uZW52aXJvbm1lbnRQcm9wLFxuICAgICAgLi4ucGVybWlzc2lvbnNQcm9wLFxuICAgIH07XG4gIH1cbn1cbiJdfQ==